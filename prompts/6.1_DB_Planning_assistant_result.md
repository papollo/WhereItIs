<conversation_summary>
<decisions>
1. Nazwy pokoi unikalne per użytkownik; nazwy mebli unikalne per pokój; unikalność case-insensitive (lowercase).
2. Pokoje prostokątne: siatka 0.5 m, przechowujemy x/y startu (metry), width/height w komórkach (max 50/50), kolor HEX z walidacją regex, brak mapy komórek. Wartości tylko dodatnie.
3. Kolory zapisujemy jako HEX z CHECK i domyślną wartością.
4. Przedmioty mogą się powtarzać w meblu; wielkość liter bez znaczenia (porównania lowercase).
5. Kaskadowe usuwanie: pokój usuwa meble i przedmioty; mebel usuwa swoje przedmioty; brak cofania/soft delete.
6. Wyszukiwanie przedmiotów przez częściowy fragment (ILIKE '%fragment%'); case-insensitive.
7. Limity długości: pokój name ≤120, mebel name ≤150, przedmiot name ≤200.
8. Logi: pola timestamp, user_id, room_id, furniture_id, item_id, message (≤500 znaków), retention 30 dni, usuwanie cronem.
9. Onboarding: tabela/rekord 1:1 z użytkownikiem, flagi completed_at/last_step (zaakceptowane).
10. RLS: user_id (uuid) referencja do auth.users w każdej tabeli domenowej; policies user_id = auth.uid().
11. Audyt: created_at, updated_at; created_by = user_id dla pokoi i mebli; dla przedmiotów created_by może być user_id lub ai_model; brak audytu aktualizacji.
12. Opis mebla jest opcjonalny. Maksymlany limit długości opisu mebla to 500 znaków.
13. ai_model to zahardcodowana wartość id taka jak dla user_id (uuid).
</decisions>

<matched_recommendations>
1. Normalizacja nazw do lowercase i unikalność w odpowiednich zakresach (pokój per user, mebel per room).
2. CHECK na HEX kolor i default wartości; użycie pól x/y + width/height zamiast pełnej mapy.
3. Kaskadowe FK (pokój→mebel→przedmiot), bez soft delete.
4. Wyszukiwanie case-insensitive przez ILIKE na items.name z normalizacją; indeks na lower(name) pod filtrację.
5. Limit długości pól tekstowych i niepustość nazw.
6. Logi zdarzeń z minimalnym payloadem + TTL/cron na 30 dni.
7. RLS oparte na user_id = auth.uid() na wszystkich tabelach domenowych; referencje do auth.users.
8. Onboarding jako osobna tabela 1:1 z użytkownikiem (completed_at, last_step).
9. Stempli czasu created_at/updated_at oraz created_by (różnicowanie dla items).
</matched_recommendations>

<database_planning_summary>
- Schemat domeny: users (auth.users), rooms (user-scoped, unikalne name lowercase, x/y metry, width/height w komórkach 0.5 m, max 50, kolor HEX z CHECK/default), furniture (room-scoped, unikalne name lowercase, opis, kolor HEX), items (furniture-scoped, name case-insensitive search, duplikaty dozwolone, created_by user/ai_model), onboarding (1:1 z user, completed_at, last_step), event_logs (timestamp, user_id, room_id, furniture_id, item_id, message ≤500, retention 30 dni).
- Relacje: user 1—N rooms; room 1—N furniture; furniture 1—N items; onboarding 1—1 user; logs opcjonalnie referencyjne do room/furniture/item + obowiązkowe user_id.
- Bezpieczeństwo: RLS na tabelach domenowych (user_id = auth.uid()); FK do auth.users; kaskadowe usuwanie na relacjach room→furniture→items; brak soft delete.
- Wydajność: indeksy unikalne na lower(name) w odpowiednich zakresach; indeks na lower(items.name) pod ILIKE; ograniczenia długości tekstu i CHECK na HEX; grid przechowywany jako wymiary, nie mapa.
- Utrzymanie: cron/TTL do kasowania logów >30 dni; brak audytu aktualizacji; stemple czasu created_at/updated_at; created_by zgodnie z rolą (user/ai_model dla items).
</database_planning_summary>

</conversation_summary>
