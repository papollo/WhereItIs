Jako starszy programista frontendu Twoim zadaniem jest stworzenie szczegółowego planu wdrożenia nowego widoku w aplikacji internetowej. Plan ten powinien być kompleksowy i wystarczająco jasny dla innego programisty frontendowego, aby mógł poprawnie i wydajnie wdrożyć widok.

Najpierw przejrzyj następujące informacje:

1. Product Requirements Document (PRD):
   <prd>
   /prompts/main/prd.md
   </prd>

2. Opis widoku:
   <view_description>

- Nazwa widoku: Lista pokojów (Dashboard)
   - Ścieżka widoku: /rooms
   - Główny cel: Przegląd i zarządzanie pokojami.
   - Kluczowe informacje do wyświetlenia: Lista pokojów z nazwą i kolorem; CTA „Dodaj pokój”.
   - Kluczowe komponenty widoku: Lista kart/wierszy pokoju, przycisk „Dodaj pokój”, przycisk „Edytuj” przy każdym pokoju.
   - UX, dostępność i względy bezpieczeństwa: Puste stany, obsługa błędów API (toast), dostępność listy i przycisków.

- Nazwa widoku: Szczegóły pokoju
   - Ścieżka widoku: /rooms/:roomId
   - Główny cel: Prezentacja pokoju i mebli oraz wejście w zarządzanie przedmiotami.
   - Kluczowe informacje do wyświetlenia: Siatka/układ pokoju, lista mebli w pokoju.
   - Kluczowe komponenty widoku: Widok siatki, elementy mebli, akcja „Dodaj mebel”.
   - UX, dostępność i względy bezpieczeństwa: Kliknięcie mebla otwiera modal; mebel z wyszukania podświetlany na czerwono.

- Nazwa widoku: Edytor pokoju
   - Ścieżka widoku: /rooms/new, /rooms/:roomId/edit
   - Główny cel: Tworzenie/edycja pokoju wraz z rysowaniem siatki.
   - Kluczowe informacje do wyświetlenia: Nazwa pokoju (max 100 znaków), paleta kolorów (do 20), siatka do 40x40.
   - Kluczowe komponenty widoku: Formularz metadanych, edytor siatki, przyciski „Zapisz” i „Anuluj”.
   - UX, dostępność i względy bezpieczeństwa: Zapis tylko po kliknięciu „Zapisz”; niezapisane zmiany przepadają; kratki muszą się stykać; kliknięcie usuwa zaznaczenie.

  </view_description>

3. User Stories:
   <user_stories>

#### US-004 Dodanie pokoju

Tytuł: Tworzenie pokoju  
Opis: Jako użytkownik chcę utworzyć nowy pokój i pomalować jego siatkę, aby odwzorować rzeczywisty kształt
pomieszczenia.  
Kryteria akceptacji:

- Użytkownik nadaje unikalną nazwę i wybiera kolor pokoju.
- Użytkownik widzi siatkę 0,5 m.
- Użytkownik może malować komórki siatki.
- Pokój zapisuje się poprawnie w bazie.

#### US-005 Edycja pokoju

Tytuł: Edytowanie pokoju  
Opis: Jako użytkownik chcę zmodyfikować nazwę, kolor lub wygląd siatki pokoju.  
Kryteria akceptacji:

- Użytkownik może zmienić nazwę i kolor.
- Użytkownik może przemalować siatkę.
- Zmiany są zapisywane po zatwierdzeniu.

#### US-006 Usuwanie pokoju

Tytuł: Usuwanie pokoju  
Opis: Jako użytkownik chcę usunąć pokój, którego już nie potrzebuję.  
Kryteria akceptacji:

- Usunięcie wymaga potwierdzenia.
- Usunięcie pokoju powoduje usunięcie przypisanych mebli i przedmiotów.
- Po usunięciu element jest natychmiast usuwany z UI.

   </user_stories>

4. Endpoint Description:
   <endpoint_description>

#### List rooms

- HTTP Method: `GET`
- URL Path: `/rest/v1/rooms`
- Description: List rooms owned by the authenticated user.
- Query Params (examples):
   - `select=id,name,color,x_start,y_start,width_cells,height_cells,cell_size_m,created_at,updated_at`
   - `order=created_at.desc`
   - `limit=50&offset=0`
   - `name=ilike.*kitchen*` (optional filter)
- Response JSON:
  -
  `[ { "id": "uuid", "name": "Kitchen", "color": "#ffffff", "x_start": 0, "y_start": 0, "width_cells": 40, "height_cells": 40, "cell_size_m": 0.5, "created_at": "...", "updated_at": "..." } ]`
- Success:
   - `200 OK`
- Errors:
   - `401 Unauthorized`

#### Create room

- HTTP Method: `POST`
- URL Path: `/rest/v1/rooms`
- Description: Create a new room.
- Query Params:
   - `select=*` (optional; return created row)
- Request JSON:
  -
  `{ "user_id": "<auth.uid()>", "created_by": "<auth.uid()>", "name": "Kitchen", "color": "#aabbcc", "x_start": 0, "y_start": 0, "width_cells": 40, "height_cells": 40, "cell_size_m": 0.5 }`
- Response JSON:
   - `[ { "id": "uuid", ... } ]`
- Success:
   - `201 Created` (or `200 OK` depending on client/Prefer headers)
- Errors:
   - `400 Bad Request` (malformed JSON)
   - `401 Unauthorized`
   - `409 Conflict` (room name already exists for user due to `rooms_user_name_lower_uidx`)
   - `422 Unprocessable Entity` (check constraint violations: name length, color hex, cell size, dimensions)

#### Get room by id

- HTTP Method: `GET`
- URL Path: `/rest/v1/rooms`
- Description: Fetch a single room by id.
- Query Params:
   - `id=eq.<room_id>`
   - `select=*`
- Response JSON:
   - `[ { "id": "uuid", ... } ]` (PostgREST returns arrays; client should expect 0/1 row)
- Success:
   - `200 OK`
- Errors:
   - `401 Unauthorized`

#### Update room

- HTTP Method: `PATCH`
- URL Path: `/rest/v1/rooms`
- Description: Update room metadata (name/color/grid definition).
- Query Params:
   - `id=eq.<room_id>`
   - `select=*` (optional)
- Request JSON (example):
   - `{ "name": "Kitchen (new)", "color": "#112233" }`
- Response JSON:
   - `[ { "id": "uuid", ... } ]`
- Success:
   - `200 OK`
- Errors:
   - `401 Unauthorized`
   - `409 Conflict` (name uniqueness)
   - `422 Unprocessable Entity` (constraints)

#### Delete room

- HTTP Method: `DELETE`
- URL Path: `/rest/v1/rooms`
- Description: Delete a room (cascades to furniture and items via FK `on delete cascade`).
- Query Params:
   - `id=eq.<room_id>`
- Response JSON: none (or `[]` depending on Prefer)
- Success:
   - `204 No Content`
- Errors:
   - `401 Unauthorized`

   </endpoint_description>

5. Endpoint Implementation:
   <endpoint_implementation>
   /frontend/src/app/rooms/rooms.api.ts
   </endpoint_implementation>

6. Type Definitions:
   <type_definitions> 
/prompts/additional/database.types.ts
   </type_definitions>

7. Tech Stack:
   <tech_stack>
/prompts/main/tech_stack.md
   </tech_stack>

Przed utworzeniem ostatecznego planu wdrożenia przeprowadź analizę i planowanie wewnątrz tagów <implementation_breakdown> w swoim bloku myślenia. Ta sekcja może być dość długa, ponieważ ważne jest, aby być dokładnym.

W swoim podziale implementacji wykonaj następujące kroki:
1. Dla każdej sekcji wejściowej (PRD, User Stories, Endpoint Description, Endpoint Implementation, Type Definitions, Tech Stack):
- Podsumuj kluczowe punkty
- Wymień wszelkie wymagania lub ograniczenia
- Zwróć uwagę na wszelkie potencjalne wyzwania lub ważne kwestie
2. Wyodrębnienie i wypisanie kluczowych wymagań z PRD
3. Wypisanie wszystkich potrzebnych głównych komponentów, wraz z krótkim opisem ich opisu, potrzebnych typów, obsługiwanych zdarzeń i warunków walidacji
4. Stworzenie wysokopoziomowego diagramu drzewa komponentów
5. Zidentyfikuj wymagane DTO i niestandardowe typy ViewModel dla każdego komponentu widoku. Szczegółowo wyjaśnij te nowe typy, dzieląc ich pola i powiązane typy.
6. Zidentyfikuj potencjalne zmienne stanu i niestandardowe hooki, wyjaśniając ich cel i sposób ich użycia
7. Wymień wymagane wywołania API i odpowiadające im akcje frontendowe
8. Zmapuj każdej historii użytkownika do konkretnych szczegółów implementacji, komponentów lub funkcji
9. Wymień interakcje użytkownika i ich oczekiwane wyniki
10. Wymień warunki wymagane przez API i jak je weryfikować na poziomie komponentów
11. Zidentyfikuj potencjalne scenariusze błędów i zasugeruj, jak sobie z nimi poradzić
12. Wymień potencjalne wyzwania związane z wdrożeniem tego widoku i zasugeruj możliwe rozwiązania

Po przeprowadzeniu analizy dostarcz plan wdrożenia w formacie Markdown z następującymi sekcjami:

1. Przegląd: Krótkie podsumowanie widoku i jego celu.
2. Routing widoku: Określenie ścieżki, na której widok powinien być dostępny.
3. Struktura komponentów: Zarys głównych komponentów i ich hierarchii.
4. Szczegóły komponentu: Dla każdego komponentu należy opisać:
- Opis komponentu, jego przeznaczenie i z czego się składa
- Główne elementy HTML i komponenty dzieci, które budują komponent
- Obsługiwane zdarzenia
- Warunki walidacji (szczegółowe warunki, zgodnie z API)
- Typy (DTO i ViewModel) wymagane przez komponent
- Propsy, które komponent przyjmuje od rodzica (interfejs komponentu)
5. Typy: Szczegółowy opis typów wymaganych do implementacji widoku, w tym dokładny podział wszelkich nowych typów lub modeli widoku według pól i typów.
6. Zarządzanie stanem: Szczegółowy opis sposobu zarządzania stanem w widoku, określenie, czy wymagany jest customowy hook.
7. Integracja API: Wyjaśnienie sposobu integracji z dostarczonym punktem końcowym. Precyzyjnie wskazuje typy żądania i odpowiedzi.
8. Interakcje użytkownika: Szczegółowy opis interakcji użytkownika i sposobu ich obsługi.
9. Warunki i walidacja: Opisz jakie warunki są weryfikowane przez interfejs, których komponentów dotyczą i jak wpływają one na stan interfejsu
10. Obsługa błędów: Opis sposobu obsługi potencjalnych błędów lub przypadków brzegowych.
11. Kroki implementacji: Przewodnik krok po kroku dotyczący implementacji widoku.

Upewnij się, że Twój plan jest zgodny z PRD, historyjkami użytkownika i uwzględnia dostarczony stack technologiczny.

Ostateczne wyniki powinny być w języku polskim i zapisane w pliku o nazwie .ai/{view-name}-view-implementation-plan.md. Nie uwzględniaj żadnej analizy i planowania w końcowym wyniku.

Oto przykład tego, jak powinien wyglądać plik wyjściowy (treść jest do zastąpienia):

```markdown
# Plan implementacji widoku [Nazwa widoku]

## 1. Przegląd

[Krótki opis widoku i jego celu]

## 2. Routing widoku

[Ścieżka, na której widok powinien być dostępny]

## 3. Struktura komponentów

[Zarys głównych komponentów i ich hierarchii]

## 4. Szczegóły komponentów

### [Nazwa komponentu 1]

- Opis komponentu [opis]
- Główne elementy: [opis]
- Obsługiwane interakcje: [lista]
- Obsługiwana walidacja: [lista, szczegółowa]
- Typy: [lista]
- Propsy: [lista]

### [Nazwa komponentu 2]

[...]

## 5. Typy

[Szczegółowy opis wymaganych typów]

## 6. Zarządzanie stanem

[Opis zarządzania stanem w widoku]

## 7. Integracja API

[Wyjaśnienie integracji z dostarczonym endpointem, wskazanie typów żądania i odpowiedzi]

## 8. Interakcje użytkownika

[Szczegółowy opis interakcji użytkownika]

## 9. Warunki i walidacja

[Szczegółowy opis warunków i ich walidacji]

## 10. Obsługa błędów

[Opis obsługi potencjalnych błędów]

## 11. Kroki implementacji

1. [Krok 1]
2. [Krok 2]
3. [...]
```

Rozpocznij analizę i planowanie już teraz. Twój ostateczny wynik powinien składać się wyłącznie z planu wdrożenia w języku polskim w formacie markdown, który zapiszesz w pliku .prompts/14.1_frontend_room_view_implmentation_plan.md i nie powinien powielać ani powtarzać żadnej pracy wykonanej w podziale implementacji.