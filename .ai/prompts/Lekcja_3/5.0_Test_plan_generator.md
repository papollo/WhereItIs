Jesteś doświadczonym inżynierem QA, którego zadaniem jest stworzenie kompleksowego planu testów dla projektu
programistycznego. Przeanalizuj poniższe informacje o projekcie:

<kod_projektu>

================================================
FILE: frontend/src/index.html
================================================
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>WhereItIs</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body class="mat-typography">
  <app-root></app-root>
</body>
</html>



================================================
FILE: frontend/src/main.ts
================================================
import { bootstrapApplication } from '@angular/platform-browser';
import { provideAnimations } from '@angular/platform-browser/animations';
import { provideHttpClient } from '@angular/common/http';
import { provideRouter } from '@angular/router';
import { importProvidersFrom } from '@angular/core';

import { AppComponent } from './app/app.component';
import { appRoutes } from './app/app.routes';
import { AuthSessionModule } from './app/auth/auth-session.module';

bootstrapApplication(AppComponent, {
providers: [
importProvidersFrom(AuthSessionModule),
provideRouter(appRoutes),
provideAnimations(),
provideHttpClient(),
],
}).catch((err) => console.error(err));



================================================
FILE: frontend/src/styles.scss
================================================
/* You can add global styles to this file, and also import other style files */

html, body { height: 100%; }
body { margin: 0; font-family: Roboto, "Helvetica Neue", sans-serif; }



================================================
FILE: frontend/src/types.ts
================================================
import type { Database } from './db/database.types';

// Base helpers to keep DTOs aligned with Supabase table shapes.
type Tables = Database['public']['Tables'];
type TableRow<T extends keyof Tables> = Tables[T]['Row'];

export type PaginationMeta = {
limit: number;
offset: number;
total?: number;
};

// Core entities
export type RoomRow = TableRow<'rooms'>;
export type RoomCellRow = TableRow<'room_cells'>;
export type FurnitureRow = TableRow<'furniture'>;
export type FurniturePlacementRow = TableRow<'furniture_placements'>;
export type ItemRow = TableRow<'items'>;
export type OnboardingRow = TableRow<'onboarding'>;
export type EventLogRow = TableRow<'event_logs'>;

// Auth DTOs (Supabase Auth)
export type AuthSignupRequest = {
email: string;
password: string;
};

export type AuthSignupResponse = {
user: { id: string; email: string };
session: { access_token: string };
};

export type AuthLoginRequest = {
email: string;
password: string;
};

export type AuthLoginResponse = {
access_token: string;
refresh_token: string;
user: { id: string };
};

export type AuthLogoutResponse = {
message: string;
};

// Rooms
export type RoomListItem = Pick<RoomRow, 'id' | 'name' | 'color'>;
export type RoomListResponse = {
data: RoomListItem[];
meta: PaginationMeta;
};

export type RoomCreateRequest = Pick<RoomRow, 'name' | 'color'>;
export type RoomCreateResponse = Pick<RoomRow, 'id' | 'name' | 'color' | 'created_at'>;

export type RoomDetailResponse = Pick<
RoomRow,
'id' | 'name' | 'color' | 'created_at' | 'updated_at'
>;

export type RoomUpdateRequest = Partial<Pick<RoomRow, 'name' | 'color'>>;
export type RoomUpdateResponse = Pick<RoomRow, 'id' | 'name' | 'color' | 'updated_at'>;

export type DeleteResponse = {
message: string;
};

// Room cells
export type RoomCell = Pick<RoomCellRow, 'x' | 'y'>;

export type RoomCellsGetResponse = {
room_id: RoomRow['id'];
cells: RoomCell[];
};

export type RoomCellsPutRequest = {
cells: RoomCell[];
};

export type RoomCellsPutResponse = {
room_id: RoomRow['id'];
cells_saved: number;
};

// Furniture
export type FurnitureListItem = Pick<FurnitureRow, 'id' | 'name' | 'color'>;
export type FurnitureListResponse = {
data: FurnitureListItem[];
meta?: PaginationMeta;
};

export type FurnitureCreateRequest = Pick<FurnitureRow, 'name' | 'description' | 'color'>;
export type FurnitureCreateResponse = Pick<
FurnitureRow,
'id' | 'room_id' | 'name' | 'color'
>;

export type FurnitureDetailResponse = Pick<
FurnitureRow,
'id' | 'room_id' | 'name' | 'description' | 'color'
>;

export type FurnitureUpdateRequest = Partial<
Pick<FurnitureRow, 'name' | 'description' | 'color'>
>;

export type FurnitureUpdateResponse = Pick<
FurnitureRow,
'id' | 'name' | 'description' | 'color' | 'updated_at'
>;

// Furniture placements
export type FurniturePlacementGetResponse = FurniturePlacementRow;

export type FurniturePlacementPutRequest = Omit<FurniturePlacementRow, 'furniture_id'>;

export type FurniturePlacementPutResponse = FurniturePlacementRow;

// Items
export type ItemListItem = Pick<ItemRow, 'id' | 'name'>;
export type ItemListResponse = {
data: ItemListItem[];
meta?: PaginationMeta;
};

export type ItemCreateInput = Pick<ItemRow, 'name'>;

export type ItemCreateRequest = {
items: ItemCreateInput[];
};

export type ItemCreateFailure = {
name: ItemRow['name'];
error?: string;
};

export type ItemCreateResponse = {
created: ItemListItem[];
failed: ItemCreateFailure[];
};

export type ItemRenameRequest = Pick<ItemRow, 'name'>;
export type ItemRenameResponse = Pick<ItemRow, 'id' | 'name' | 'updated_at'>;

// Search
export type SearchItemResult = {
item_id: ItemRow['id'];
item_name: ItemRow['name'];
furniture: Pick<FurnitureRow, 'id' | 'name'>;
room: Pick<RoomRow, 'id' | 'name'>;
};

export type SearchItemsResponse = {
data: SearchItemResult[];
};

// Onboarding
export type OnboardingGetResponse = OnboardingRow;
export type OnboardingUpsertRequest = Pick<OnboardingRow, 'completed_at' | 'last_step'>;
export type OnboardingUpsertResponse = OnboardingRow;

// Event logs
export type EventLogCreateRequest = Pick<
EventLogRow,
'event_time' | 'message' | 'room_id' | 'furniture_id' | 'item_id'
>;

export type EventLogCreateResponse = Pick<EventLogRow, 'id' | 'message'>;

export type EventLogListItem = Pick<EventLogRow, 'id' | 'message' | 'event_time'>;
export type EventLogListResponse = {
data: EventLogListItem[];
meta?: PaginationMeta;
};



================================================
FILE: frontend/src/app/app.component.html
================================================
<ng-container *ngIf="isAuthRoute; else appShell">
  <main class="auth-content">
    <router-outlet />
  </main>
</ng-container>

<ng-template #appShell>
  <div class="app-shell">
    <nav class="sidebar" aria-label="Nawigacja boczna">
      <div class="sidebar__title">WhereItIs</div>
      <div class="sidebar__section">
        <a class="sidebar__link" routerLink="/rooms" routerLinkActive="is-active">
          Pokoje
        </a>
        <a class="sidebar__link" routerLink="/search" routerLinkActive="is-active">
          Wyszukiwanie
        </a>
        <a class="sidebar__link" routerLink="/user/edit" routerLinkActive="is-active">
          Edycja uzytkownika
        </a>
    </div>
    <div class="sidebar__section sidebar__section--bottom">
      <button
        class="sidebar__link"
        type="button"
        (click)="logout()"
        [disabled]="isLoggingOut || !(isAuthenticated$ | async)"
      >
        Wyloguj
      </button>
    </div>
  </nav>
    <main class="app-content">
      <router-outlet />
    </main>
  </div>
</ng-template>



================================================
FILE: frontend/src/app/app.component.scss
================================================
.app-shell {
display: flex;
min-height: 100vh;
background: #f6f6f3;
color: #1f1f1c;
}

.sidebar {
width: 220px;
padding: 24px 16px;
box-sizing: border-box;
border-right: 1px solid #d8d6cf;
background: #efece3;
display: flex;
flex-direction: column;
gap: 24px;
}

.sidebar__title {
font-size: 18px;
font-weight: 700;
letter-spacing: 0.3px;
}

.sidebar__section {
display: flex;
flex-direction: column;
gap: 8px;
}

.sidebar__section--bottom {
margin-top: auto;
}

.sidebar__link {
display: inline-flex;
align-items: center;
justify-content: flex-start;
padding: 10px 12px;
border-radius: 10px;
border: 1px solid transparent;
background: transparent;
color: inherit;
text-decoration: none;
font: inherit;
cursor: pointer;
transition: background 0.2s ease, border-color 0.2s ease;
}

.sidebar__link:hover {
background: rgba(31, 31, 28, 0.06);
border-color: rgba(31, 31, 28, 0.12);
}

.sidebar__link.is-active {
background: #1f1f1c;
border-color: #1f1f1c;
color: #f8f6ef;
}

.sidebar__link.is-disabled {
opacity: 0.45;
cursor: not-allowed;
}

.sidebar__link:disabled {
opacity: 0.45;
cursor: not-allowed;
}

.app-content {
flex: 1;
padding: 24px;
box-sizing: border-box;
}

.auth-content {
min-height: 100vh;
background: #f6f6f3;
}



================================================
FILE: frontend/src/app/app.component.spec.ts
================================================
import { TestBed } from '@angular/core/testing';
import { RouterTestingModule } from '@angular/router/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () => {
beforeEach(async () => {
await TestBed.configureTestingModule({
imports: [
RouterTestingModule,
AppComponent,
],
}).compileComponents();
});

it('should create the app', () => {
const fixture = TestBed.createComponent(AppComponent);
const app = fixture.componentInstance;
expect(app).toBeTruthy();
});

it(`should have as title 'WhereItIs'`, () => {
const fixture = TestBed.createComponent(AppComponent);
const app = fixture.componentInstance;
expect(app.title).toEqual('WhereItIs');
});

it('should render router outlet', () => {
const fixture = TestBed.createComponent(AppComponent);
fixture.detectChanges();
const compiled = fixture.nativeElement as HTMLElement;
expect(compiled.querySelector('router-outlet')).toBeTruthy();
});
});



================================================
FILE: frontend/src/app/app.component.ts
================================================
import { AsyncPipe, NgIf } from '@angular/common';
import { Component, DestroyRef, inject } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { NavigationEnd, Router, RouterLink, RouterLinkActive, RouterOutlet } from '@angular/router';
import { filter } from 'rxjs';
import { AuthApi } from './auth/auth.api';
import { AuthSessionService } from './auth/auth-session.service';

@Component({
selector: 'app-root',
imports: [AsyncPipe, NgIf, RouterOutlet, RouterLink, RouterLinkActive, MatSnackBarModule],
templateUrl: './app.component.html',
styleUrls: ['./app.component.scss'],
})
export class AppComponent {
private readonly router = inject(Router);
private readonly destroyRef = inject(DestroyRef);
private readonly authApi = inject(AuthApi);
private readonly authSession = inject(AuthSessionService);
private readonly snackBar = inject(MatSnackBar);

isAuthRoute = this.isAuthUrl(this.router.url);
isLoggingOut = false;
readonly isAuthenticated$ = this.authSession.isAuthenticated$;

constructor() {
this.router.events
.pipe(
filter((event): event is NavigationEnd => event instanceof NavigationEnd),
takeUntilDestroyed(this.destroyRef)
)
.subscribe((event) => {
this.isAuthRoute = this.isAuthUrl(event.urlAfterRedirects);
});
}

private isAuthUrl(url: string): boolean {
return (
url.startsWith('/login') ||
url.startsWith('/register') ||
url.startsWith('/forgot-password') ||
url.startsWith('/reset-password')
);
}

async logout(): Promise<void> {
if (this.isLoggingOut) {
return;
}

    this.isLoggingOut = true;

    try {
      await this.authApi.logout();
      this.snackBar.open('Wylogowano.', 'Zamknij', { duration: 2500 });
      await this.router.navigate(['/login']);
    } catch (err) {
      this.snackBar.open('Nie udalo sie wylogowac.', 'Zamknij', { duration: 3000 });
    } finally {
      this.isLoggingOut = false;
    }
}
}



================================================
FILE: frontend/src/app/app.routes.ts
================================================
import type { Routes } from '@angular/router';
import { RoomDetailsPageComponent } from './rooms/pages/room-details-page/room-details-page.component';
import { RoomEditorPageComponent } from './rooms/pages/room-editor-page/room-editor-page.component';
import { RoomsListPageComponent } from './rooms/pages/rooms-list-page/rooms-list-page.component';
import { SearchPageComponent } from './search/pages/search-page/search-page.component';
import { UserEditPageComponent } from './user/pages/user-edit-page/user-edit-page.component';
import { ForgotPasswordPageComponent } from './auth/pages/forgot-password-page/forgot-password-page.component';
import { LoginPageComponent } from './auth/pages/login-page/login-page.component';
import { RegisterPageComponent } from './auth/pages/register-page/register-page.component';
import { ResetPasswordPageComponent } from './auth/pages/reset-password-page/reset-password-page.component';
import { authGuard } from './auth/guards/auth.guard';
import { guestGuard } from './auth/guards/guest.guard';

export const appRoutes: Routes = [
{ path: '', redirectTo: 'rooms', pathMatch: 'full' },
{ path: 'login', component: LoginPageComponent, canActivate: [guestGuard] },
{ path: 'register', component: RegisterPageComponent, canActivate: [guestGuard] },
{ path: 'forgot-password', component: ForgotPasswordPageComponent, canActivate: [guestGuard] },
{ path: 'reset-password', component: ResetPasswordPageComponent },
{ path: 'rooms', component: RoomsListPageComponent, canActivate: [authGuard] },
{ path: 'rooms/new', component: RoomEditorPageComponent, canActivate: [authGuard] },
{ path: 'rooms/:roomId', component: RoomDetailsPageComponent, canActivate: [authGuard] },
{ path: 'rooms/:roomId/edit', component: RoomEditorPageComponent, canActivate: [authGuard] },
{ path: 'search', component: SearchPageComponent, canActivate: [authGuard] },
{ path: 'user/edit', component: UserEditPageComponent, canActivate: [authGuard] },
{ path: '**', redirectTo: 'rooms' },
];



================================================
FILE: frontend/src/app/auth/auth-session.module.ts
================================================
import { APP_INITIALIZER, NgModule } from '@angular/core';
import { AuthSessionService } from './auth-session.service';

function initAuthSession(authSession: AuthSessionService): () => Promise<void> {
return () => authSession.init();
}

@NgModule({
providers: [
AuthSessionService,
{
provide: APP_INITIALIZER,
useFactory: initAuthSession,
deps: [AuthSessionService],
multi: true,
},
],
})
export class AuthSessionModule {}



================================================
FILE: frontend/src/app/auth/auth-session.service.ts
================================================
import { Injectable, inject } from '@angular/core';
import type { Session, User } from '@supabase/supabase-js';
import { BehaviorSubject, distinctUntilChanged, map } from 'rxjs';
import { SupabaseService } from '../../db/supabase.service';
import { ApiError } from '../shared/api-error';

export type AuthSessionState = {
session: Session | null;
user: User | null;
loading: boolean;
};

@Injectable()
export class AuthSessionService {
private readonly supabase = inject(SupabaseService);
private readonly stateSubject = new BehaviorSubject<AuthSessionState>({
session: null,
user: null,
loading: true,
});
private initialized = false;

readonly state$ = this.stateSubject.asObservable();
readonly isAuthenticated$ = this.state$.pipe(
map((state) => Boolean(state.session)),
distinctUntilChanged()
);
readonly user$ = this.state$.pipe(
map((state) => state.user),
distinctUntilChanged()
);
readonly loading$ = this.state$.pipe(
map((state) => state.loading),
distinctUntilChanged()
);

async init(): Promise<void> {
if (this.initialized) {
return;
}

    this.initialized = true;
    this.setLoading(true);

    const { data, error } = await this.supabase.getClient().auth.getSession();

    if (error) {
      this.applySession(null);
      this.setLoading(false);
      return;
    }

    this.applySession(data.session ?? null);
    this.setLoading(false);

    this.supabase.getClient().auth.onAuthStateChange((_event, session) => {
      this.applySession(session ?? null);
    });
}

getUserIdOrThrow(): string {
const userId = this.stateSubject.value.user?.id;
if (!userId) {
throw ApiError.unauthorized('User is not authenticated');
}

    return userId;
}

async refreshSession(): Promise<void> {
const session = this.stateSubject.value.session;
if (!session?.refresh_token) {
throw ApiError.unauthorized('Refresh token missing');
}

    const { data, error } = await this.supabase.getClient().auth.setSession({
      access_token: session.access_token,
      refresh_token: session.refresh_token,
    });

    if (error) {
      throw ApiError.badRequest(error.message, undefined, error);
    }

    this.applySession(data.session ?? null);
}

private applySession(session: Session | null): void {
const loading = this.stateSubject.value.loading;
this.stateSubject.next({
session,
user: session?.user ?? null,
loading,
});
}

private setLoading(loading: boolean): void {
const current = this.stateSubject.value;
if (current.loading === loading) {
return;
}

    this.stateSubject.next({ ...current, loading });
}
}



================================================
FILE: frontend/src/app/auth/auth.api.ts
================================================
import { Injectable, inject } from '@angular/core';
import { SupabaseService } from '../../db/supabase.service';
import { ApiError } from '../shared/api-error';
import type {
AuthForgotPasswordCommand,
AuthForgotPasswordResponseDto,
AuthLoginCommand,
AuthLoginResponseDto,
AuthLogoutResponseDto,
AuthResetPasswordCommand,
AuthResetPasswordResponseDto,
AuthSignupCommand,
AuthSignupResponseDto,
} from './auth.types';
import {
mapForgotPasswordAuthError,
mapLoginAuthError,
mapLogoutAuthError,
mapResetPasswordAuthError,
mapSignupAuthError,
} from './auth.errors';
import {
validateAuthForgotPasswordCommand,
validateAuthLoginCommand,
validateAuthResetPasswordCommand,
validateAuthSignupCommand,
} from './auth.validation';

@Injectable({
providedIn: 'root',
})
export class AuthApi {
private readonly supabase = inject(SupabaseService);

async signUp(command: AuthSignupCommand): Promise<AuthSignupResponseDto> {
const validationErrors = validateAuthSignupCommand(command);
if (validationErrors) {
throw ApiError.validation(validationErrors);
}

    const email = command.email.trim();
    const { data, error } = await this.supabase
      .getClient()
      .auth.signUp({ email, password: command.password });

    if (error) {
      throw mapSignupAuthError(error);
    }

    if (!data.user) {
      throw ApiError.badRequest('Signup failed to create user');
    }

    if (!data.session) {
      throw ApiError.badRequest('Signup did not return a session');
    }

    if (!data.user.email) {
      throw ApiError.badRequest('Signup did not return user email');
    }

    return {
      user: {
        id: data.user.id,
        email: data.user.email,
      },
      session: {
        access_token: data.session.access_token,
      },
    };
}

async login(command: AuthLoginCommand): Promise<AuthLoginResponseDto> {
const validationErrors = validateAuthLoginCommand(command);
if (validationErrors) {
throw ApiError.validation(validationErrors);
}

    const email = command.email.trim();
    const { data, error } = await this.supabase
      .getClient()
      .auth.signInWithPassword({ email, password: command.password });

    if (error) {
      throw mapLoginAuthError(error);
    }

    if (!data.user || !data.session) {
      throw ApiError.unauthorized('Invalid email or password');
    }

    return {
      access_token: data.session.access_token,
      refresh_token: data.session.refresh_token,
      user: {
        id: data.user.id,
      },
    };
}

async requestPasswordReset(
command: AuthForgotPasswordCommand
): Promise<AuthForgotPasswordResponseDto> {
const validationErrors = validateAuthForgotPasswordCommand(command);
if (validationErrors) {
throw ApiError.validation(validationErrors);
}

    const email = command.email.trim();
    const { error } = await this.supabase
      .getClient()
      .auth.resetPasswordForEmail(email, {
        redirectTo: `${window.location.origin}/reset-password`,
      });

    if (error) {
      throw mapForgotPasswordAuthError(error);
    }

    return { message: 'reset email sent' };
}

async resetPassword(command: AuthResetPasswordCommand): Promise<AuthResetPasswordResponseDto> {
const validationErrors = validateAuthResetPasswordCommand(command);
if (validationErrors) {
throw ApiError.validation(validationErrors);
}

    const { error: sessionError } = await this.supabase.getClient().auth.setSession({
      access_token: command.access_token,
      refresh_token: command.refresh_token,
    });

    if (sessionError) {
      throw mapResetPasswordAuthError(sessionError);
    }

    const { error } = await this.supabase.getClient().auth.updateUser({
      password: command.password,
    });

    if (error) {
      throw mapResetPasswordAuthError(error);
    }

    return { message: 'password updated' };
}

async logout(): Promise<AuthLogoutResponseDto> {
const { error } = await this.supabase.getClient().auth.signOut();

    if (error) {
      throw mapLogoutAuthError(error);
    }

    return { message: 'logged out' };
}
}



================================================
FILE: frontend/src/app/auth/auth.errors.ts
================================================
import type { AuthError } from '@supabase/supabase-js';
import { ApiError } from '../shared/api-error';

const INVALID_CREDENTIALS = ['invalid login credentials', 'invalid email or password'];
const EMAIL_EXISTS = ['already registered', 'already exists'];
const USER_NOT_FOUND = ['user not found'];
const TOKEN_EXPIRED = ['expired', 'invalid'];

function matches(message: string, phrases: string[]): boolean {
return phrases.some((phrase) => message.includes(phrase));
}

function mapSupabaseAuthError(error: AuthError, status?: number): ApiError {
return new ApiError({
status: status ?? 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}

export function mapSignupAuthError(error: AuthError): ApiError {
const status = error.status ?? 500;
const message = error.message.toLowerCase();

if (status === 400) {
return ApiError.badRequest(error.message, undefined, error);
}

if (status === 409 || matches(message, EMAIL_EXISTS)) {
return new ApiError({
status: 409,
code: 'SUPABASE_ERROR',
message: 'Email already exists',
cause: error,
});
}

return mapSupabaseAuthError(error, status);
}

export function mapLoginAuthError(error: AuthError): ApiError {
const status = error.status ?? 500;
const message = error.message.toLowerCase();

if (status === 401 || status === 400 || matches(message, INVALID_CREDENTIALS)) {
return ApiError.unauthorized('Invalid email or password');
}

return mapSupabaseAuthError(error, status);
}

export function mapForgotPasswordAuthError(error: AuthError): ApiError {
const status = error.status ?? 500;
const message = error.message.toLowerCase();

if (status === 400) {
return ApiError.badRequest(error.message, undefined, error);
}

if (status === 404 || matches(message, USER_NOT_FOUND)) {
return ApiError.notFound('Email not found');
}

return mapSupabaseAuthError(error, status);
}

export function mapResetPasswordAuthError(error: AuthError): ApiError {
const status = error.status ?? 500;
const message = error.message.toLowerCase();

if (status === 400 || matches(message, TOKEN_EXPIRED)) {
return ApiError.badRequest('Reset token is invalid or expired', undefined, error);
}

return mapSupabaseAuthError(error, status);
}

export function mapLogoutAuthError(error: AuthError): ApiError {
const status = error.status ?? 500;

if (status === 401) {
return ApiError.unauthorized(error.message);
}

return mapSupabaseAuthError(error, status);
}



================================================
FILE: frontend/src/app/auth/auth.types.ts
================================================
export type AuthSignupCommand = {
email: string;
password: string;
};

export type AuthSignupResponseDto = {
user: { id: string; email: string };
session: { access_token: string };
};

export type AuthLoginCommand = {
email: string;
password: string;
};

export type AuthLoginResponseDto = {
access_token: string;
refresh_token: string;
user: { id: string };
};

export type AuthForgotPasswordCommand = {
email: string;
};

export type AuthForgotPasswordResponseDto = {
message: string;
};

export type AuthResetPasswordCommand = {
access_token: string;
password: string;
refresh_token: string;
};

export type AuthResetPasswordResponseDto = {
message: string;
};

export type AuthLogoutResponseDto = {
message: string;
};



================================================
FILE: frontend/src/app/auth/auth.validation.ts
================================================
import type {
AuthForgotPasswordCommand,
AuthLoginCommand,
AuthResetPasswordCommand,
AuthSignupCommand,
} from './auth.types';

const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
const MIN_PASSWORD_LENGTH = 6;

function validateEmail(value: string): string | null {
const trimmed = value.trim();
if (trimmed.length === 0) {
return 'email is required';
}

if (!EMAIL_REGEX.test(trimmed)) {
return 'email must be a valid address';
}

return null;
}

function validatePassword(value: string): string | null {
if (value.length === 0) {
return 'password is required';
}

if (value.length < MIN_PASSWORD_LENGTH) {
return `password must be at least ${MIN_PASSWORD_LENGTH} characters`;
}

return null;
}

function validateAccessToken(value: string): string | null {
if (value.trim().length === 0) {
return 'access_token is required';
}

return null;
}

function validateRefreshToken(value: string): string | null {
if (value.trim().length === 0) {
return 'refresh_token is required';
}

return null;
}

export function validateAuthSignupCommand(
command: AuthSignupCommand
): Record<keyof AuthSignupCommand, string> | null {
const errors: Partial<Record<keyof AuthSignupCommand, string>> = {};

const emailError = validateEmail(command.email);
if (emailError) {
errors.email = emailError;
}

const passwordError = validatePassword(command.password);
if (passwordError) {
errors.password = passwordError;
}

if (Object.keys(errors).length === 0) {
return null;
}

return errors as Record<keyof AuthSignupCommand, string>;
}

export function validateAuthLoginCommand(
command: AuthLoginCommand
): Record<keyof AuthLoginCommand, string> | null {
const errors: Partial<Record<keyof AuthLoginCommand, string>> = {};

const emailError = validateEmail(command.email);
if (emailError) {
errors.email = emailError;
}

const passwordError = validatePassword(command.password);
if (passwordError) {
errors.password = passwordError;
}

if (Object.keys(errors).length === 0) {
return null;
}

return errors as Record<keyof AuthLoginCommand, string>;
}

export function validateAuthForgotPasswordCommand(
command: AuthForgotPasswordCommand
): Record<keyof AuthForgotPasswordCommand, string> | null {
const errors: Partial<Record<keyof AuthForgotPasswordCommand, string>> = {};

const emailError = validateEmail(command.email);
if (emailError) {
errors.email = emailError;
}

if (Object.keys(errors).length === 0) {
return null;
}

return errors as Record<keyof AuthForgotPasswordCommand, string>;
}

export function validateAuthResetPasswordCommand(
command: AuthResetPasswordCommand
): Record<string, string> | null {
const errors: Record<string, string> = {};

const accessTokenError = validateAccessToken(command.access_token);
if (accessTokenError) {
errors['access_token'] = accessTokenError;
}

const refreshTokenError = validateRefreshToken(command.refresh_token);
if (refreshTokenError) {
errors['refresh_token'] = refreshTokenError;
}

const passwordError = validatePassword(command.password);
if (passwordError) {
errors['password'] = passwordError;
}

if (Object.keys(errors).length === 0) {
return null;
}

return errors;
}



================================================
FILE: frontend/src/app/auth/components/auth-form-card.component.html
================================================
<section class="auth-card">
  <header class="auth-card__header">
    <h2>{{ title }}</h2>
    <p *ngIf="subtitle">{{ subtitle }}</p>
  </header>
  <div class="auth-card__body">
    <ng-content></ng-content>
  </div>
  <footer class="auth-card__footer" *ngIf="showFooter">
    <ng-content select="[authCardFooter]"></ng-content>
  </footer>
</section>



================================================
FILE: frontend/src/app/auth/components/auth-form-card.component.scss
================================================
:host {
display: block;
width: 100%;
}

.auth-card {
width: 100%;
max-width: 860px;
padding: 28px;
border-radius: 18px;
background: #fbfaf6;
border: 1px solid #d8d6cf;
box-shadow: 0 12px 24px rgba(31, 31, 28, 0.08);
display: grid;
gap: 20px;
box-sizing: border-box;
}

.auth-card__header {
display: grid;
gap: 6px;
}

.auth-card__header h2 {
margin: 0;
font-size: 22px;
}

.auth-card__header p {
margin: 0;
color: rgba(31, 31, 28, 0.7);
}

.auth-card__body {
display: grid;
gap: 16px;
}

.auth-card__footer {
display: flex;
flex-wrap: wrap;
gap: 6px;
font-size: 14px;
color: rgba(31, 31, 28, 0.75);
}

.auth-card__footer a {
color: inherit;
font-weight: 600;
text-decoration: none;
}

.auth-card__footer a:hover {
text-decoration: underline;
}



================================================
FILE: frontend/src/app/auth/components/auth-form-card.component.ts
================================================
import { NgIf } from '@angular/common';
import { Component, Input } from '@angular/core';

@Component({
selector: 'app-auth-form-card',
standalone: true,
imports: [NgIf],
templateUrl: './auth-form-card.component.html',
styleUrls: ['./auth-form-card.component.scss'],
})
export class AuthFormCardComponent {
@Input({ required: true }) title = '';
@Input() subtitle?: string;
@Input() showFooter = true;
}



================================================
FILE: frontend/src/app/auth/components/inline-error.component.ts
================================================
import { NgIf } from '@angular/common';
import { Component, Input } from '@angular/core';

@Component({
selector: 'app-inline-error',
standalone: true,
imports: [NgIf],
template: `
    <p class="inline-error" role="alert" *ngIf="message">{{ message }}</p>
  `,
styles: [
`
      .inline-error {
        margin: 0;
        font-size: 13px;
        color: #b3261e;
      }
    `,
],
})
export class InlineErrorComponent {
@Input() message = '';
}



================================================
FILE: frontend/src/app/auth/components/password-field.component.html
================================================
<mat-form-field appearance="outline" class="password-field" subscriptSizing="dynamic">
<mat-label>{{ label }}</mat-label>
<input
matInput
[type]="isVisible ? 'text' : 'password'"
[formControl]="control"
[attr.autocomplete]="autocomplete"
/>
<button
mat-button
matSuffix
type="button"
class="password-field__toggle"
(click)="toggleVisibility()"
[attr.aria-pressed]="isVisible"
>
    {{ isVisible ? 'Ukryj' : 'Pokaz' }}
  </button>
  <mat-hint *ngIf="hint">{{ hint }}</mat-hint>
</mat-form-field>
<div
  class="password-field__errors mat-mdc-form-field-subscript-wrapper mat-mdc-form-field-bottom-align"
  aria-live="polite"
  aria-atomic="true"
>
  <div class="mat-mdc-form-field-error-wrapper">
    <ng-content select="mat-error"></ng-content>
  </div>
</div>



================================================
FILE: frontend/src/app/auth/components/password-field.component.scss
================================================
:host {
display: block;
width: 100%;
}

mat-form-field {
width: 100%;
}

.password-field__errors {
margin-top: 0;
padding: 0 16px;
display: grid;
gap: 4px;
min-height: 16px;
}

.password-field__errors mat-error {
display: block;
color: var(--mat-form-field-error-text-color, #f44336);
font-family: var(--mat-form-field-subscript-text-font, inherit);
font-size: var(--mat-form-field-subscript-text-size, 12px);
line-height: var(--mat-form-field-subscript-text-line-height, 16px);
font-weight: var(--mat-form-field-subscript-text-weight, 400);
letter-spacing: var(--mat-form-field-subscript-text-tracking, normal);
}

.password-field__toggle {
font-size: 12px;
line-height: 1;
padding: 4px 8px;
}



================================================
FILE: frontend/src/app/auth/components/password-field.component.ts
================================================
import { NgIf } from '@angular/common';
import { Component, Input } from '@angular/core';
import { FormControl, ReactiveFormsModule } from '@angular/forms';
import { MatButtonModule } from '@angular/material/button';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';

@Component({
selector: 'app-password-field',
standalone: true,
imports: [ReactiveFormsModule, MatFormFieldModule, MatInputModule, MatButtonModule, NgIf],
templateUrl: './password-field.component.html',
styleUrls: ['./password-field.component.scss'],
})
export class PasswordFieldComponent {
@Input({ required: true }) control!: FormControl<string>;
@Input() label = 'Haslo';
@Input() autocomplete = 'current-password';
@Input() hint?: string;

isVisible = false;

toggleVisibility(): void {
this.isVisible = !this.isVisible;
}
}



================================================
FILE: frontend/src/app/auth/guards/auth.guard.ts
================================================
import { inject } from '@angular/core';
import type { CanActivateFn } from '@angular/router';
import { Router } from '@angular/router';
import { filter, map, take } from 'rxjs';
import { AuthSessionService } from '../auth-session.service';

export const authGuard: CanActivateFn = () => {
const authSession = inject(AuthSessionService);
const router = inject(Router);

return authSession.state$.pipe(
filter((state) => !state.loading),
take(1),
map((state) => (state.session ? true : router.createUrlTree(['/login'])))
);
};



================================================
FILE: frontend/src/app/auth/guards/guest.guard.ts
================================================
import { inject } from '@angular/core';
import type { CanActivateFn } from '@angular/router';
import { Router } from '@angular/router';
import { filter, map, take } from 'rxjs';
import { AuthSessionService } from '../auth-session.service';

export const guestGuard: CanActivateFn = () => {
const authSession = inject(AuthSessionService);
const router = inject(Router);

return authSession.state$.pipe(
filter((state) => !state.loading),
take(1),
map((state) => (state.session ? router.createUrlTree(['/rooms']) : true))
);
};



================================================
FILE: frontend/src/app/auth/layouts/auth-layout.component.html
================================================
<main class="auth-layout">
  <section class="auth-layout__panel">
    <header class="auth-layout__intro">
      <div class="auth-layout__logo">WhereItIs</div>
      <h1>Twoja mapa domu w jednym miejscu.</h1>
      <p>Zaloguj sie lub zaloz konto, aby wracac do swoich pokojow i przedmiotow.</p>
      <div class="auth-layout__chips" aria-hidden="true">
        <span class="auth-layout__chip">Pokoje</span>
        <span class="auth-layout__chip">Meble</span>
        <span class="auth-layout__chip">Przedmioty</span>
      </div>
    </header>
    <div class="auth-layout__content">
      <ng-content></ng-content>
    </div>
  </section>
</main>



================================================
FILE: frontend/src/app/auth/layouts/auth-layout.component.scss
================================================
.auth-layout {
min-height: 100vh;
padding: 32px 16px;
background: #f6f6f3;
color: #1f1f1c;
box-sizing: border-box;
display: flex;
align-items: center;
justify-content: center;
}

.auth-layout__panel {
width: min(1200px, 100%);
display: grid;
gap: 32px;
align-items: center;
}

.auth-layout__intro {
display: grid;
gap: 12px;
}

.auth-layout__logo {
font-size: 20px;
font-weight: 700;
letter-spacing: 0.4px;
}

.auth-layout__intro h1 {
margin: 0;
font-size: 28px;
}

.auth-layout__intro p {
margin: 0;
color: rgba(31, 31, 28, 0.7);
max-width: 420px;
}

.auth-layout__chips {
display: flex;
flex-wrap: wrap;
gap: 8px;
}

.auth-layout__chip {
padding: 6px 12px;
border-radius: 999px;
background: #efece3;
border: 1px solid #d8d6cf;
font-size: 13px;
}

.auth-layout__content {
display: flex;
justify-content: flex-start;
width: 100%;
}

@media (min-width: 900px) {
.auth-layout__panel {
grid-template-columns: 1fr 1.3fr;
}

.auth-layout__content {
justify-content: flex-end;
}
}

@media (max-width: 599px) {
.auth-layout__intro h1 {
font-size: 24px;
}
}



================================================
FILE: frontend/src/app/auth/layouts/auth-layout.component.ts
================================================
import { Component } from '@angular/core';

@Component({
selector: 'app-auth-layout',
standalone: true,
templateUrl: './auth-layout.component.html',
styleUrls: ['./auth-layout.component.scss'],
})
export class AuthLayoutComponent {}



================================================
FILE: frontend/src/app/auth/pages/forgot-password-page/forgot-password-page.component.html
================================================
<app-auth-layout>
<app-auth-form-card
[title]="isEmailSent ? 'Sprawdz poczte' : 'Odzyskaj konto'"
[subtitle]="
isEmailSent
? 'Wyslalismy link resetu hasla na podany adres email.'
: 'Wyslemy link resetu hasla na podany adres email.'
"
[showFooter]="!isEmailSent"
>
    <ng-container *ngIf="!isEmailSent; else emailSent">
      <form [formGroup]="form" (ngSubmit)="submit()" class="auth-form">
        <mat-form-field appearance="outline">
          <mat-label>Email</mat-label>
          <input matInput type="email" formControlName="email" autocomplete="email" />
          <mat-error *ngIf="form.controls.email.hasError('required')">
            Email jest wymagany.
          </mat-error>
          <mat-error *ngIf="form.controls.email.hasError('email')">
            Podaj poprawny adres email.
          </mat-error>
        </mat-form-field>

        <app-inline-error [message]="formError"></app-inline-error>

        <button mat-flat-button color="primary" type="submit" [disabled]="isSubmitting">
          Wyslij link resetu
        </button>
      </form>
    </ng-container>

    <ng-template #emailSent>
      <div class="auth-form">
        <p>Jesli adres istnieje w naszej bazie, link resetu jest juz w drodze.</p>
        <a mat-flat-button color="primary" routerLink="/login">
          Wroc do widoku logowania
        </a>
      </div>
    </ng-template>

    <div authCardFooter class="auth-card__footer-content">
      <span>Wrocic do logowania?</span>
      <a routerLink="/login">Zaloguj sie</a>
    </div>
  </app-auth-form-card>
</app-auth-layout>



================================================
FILE: frontend/src/app/auth/pages/forgot-password-page/forgot-password-page.component.scss
================================================
.auth-form {
display: grid;
gap: 16px;
}

.auth-form mat-form-field,
.auth-form app-password-field {
width: 100%;
display: block;
}



================================================
FILE: frontend/src/app/auth/pages/forgot-password-page/forgot-password-page.component.ts
================================================
import { NgIf } from '@angular/common';
import { ChangeDetectorRef, Component, inject } from '@angular/core';
import { FormControl, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { MatButtonModule } from '@angular/material/button';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { RouterLink } from '@angular/router';
import { ApiError } from '../../../shared/api-error';
import { AuthApi } from '../../auth.api';
import { AuthFormCardComponent } from '../../components/auth-form-card.component';
import { InlineErrorComponent } from '../../components/inline-error.component';
import { AuthLayoutComponent } from '../../layouts/auth-layout.component';

@Component({
selector: 'app-forgot-password-page',
standalone: true,
imports: [
NgIf,
ReactiveFormsModule,
MatButtonModule,
MatFormFieldModule,
MatInputModule,
RouterLink,
AuthLayoutComponent,
AuthFormCardComponent,
InlineErrorComponent,
],
templateUrl: './forgot-password-page.component.html',
styleUrls: ['./forgot-password-page.component.scss'],
})
export class ForgotPasswordPageComponent {
private readonly authApi = inject(AuthApi);
private readonly cdr = inject(ChangeDetectorRef);

readonly form = new FormGroup({
email: new FormControl('', {
nonNullable: true,
validators: [Validators.required, Validators.email],
}),
});

formError = '';
isSubmitting = false;
isEmailSent = false;

async submit(): Promise<void> {
this.formError = '';
this.form.markAllAsTouched();

    if (this.form.invalid) {
      return;
    }

    this.isSubmitting = true;

    try {
      await this.authApi.requestPasswordReset(this.form.getRawValue());
      this.isEmailSent = true;
      this.cdr.detectChanges();
    } catch (err) {
      this.formError = this.formatError(err);
    } finally {
      this.isSubmitting = false;
    }
}

private formatError(error: unknown): string {
if (error instanceof ApiError) {
return error.message;
}

    if (error instanceof Error) {
      return error.message;
    }

    return 'Wystapil nieznany blad.';
}
}



================================================
FILE: frontend/src/app/auth/pages/login-page/login-page.component.html
================================================
<app-auth-layout>
<app-auth-form-card title="Zaloguj sie" subtitle="Wroc do swoich pokojow i przedmiotow.">
<form [formGroup]="form" (ngSubmit)="submit()" class="auth-form">
<mat-form-field appearance="outline">
<mat-label>Email</mat-label>
<input matInput type="email" formControlName="email" autocomplete="email" />
<mat-error *ngIf="form.controls.email.hasError('required')">
Email jest wymagany.
</mat-error>
<mat-error *ngIf="form.controls.email.hasError('email')">
Podaj poprawny adres email.
</mat-error>
</mat-form-field>

      <app-password-field
        [control]="form.controls.password"
        label="Haslo"
        autocomplete="current-password"
      >
        <mat-error
          *ngIf="
            form.controls.password.hasError('required') && form.controls.password.touched
          "
        >
          Haslo jest wymagane.
        </mat-error>
      </app-password-field>

      <app-inline-error [message]="formError"></app-inline-error>

      <div class="auth-form__actions">
        <button mat-flat-button color="primary" type="submit" [disabled]="isSubmitting">
          Zaloguj
        </button>
        <a class="auth-form__link" routerLink="/forgot-password">Nie pamietasz hasla?</a>
      </div>
    </form>

    <div authCardFooter class="auth-card__footer-content">
      <span>Nie masz konta?</span>
      <a routerLink="/register">Zarejestruj sie</a>
    </div>
  </app-auth-form-card>
</app-auth-layout>



================================================
FILE: frontend/src/app/auth/pages/login-page/login-page.component.scss
================================================
.auth-form {
display: grid;
gap: 16px;
}

.auth-form mat-form-field,
.auth-form app-password-field {
width: 100%;
display: block;
}

.auth-form__actions {
display: grid;
gap: 8px;
align-items: start;
}

.auth-form__link {
font-size: 13px;
color: rgba(31, 31, 28, 0.7);
text-decoration: none;
}

.auth-form__link:hover {
text-decoration: underline;
}



================================================
FILE: frontend/src/app/auth/pages/login-page/login-page.component.ts
================================================
import { NgIf } from '@angular/common';
import { Component, inject } from '@angular/core';
import { FormControl, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { MatButtonModule } from '@angular/material/button';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { Router, RouterLink } from '@angular/router';
import { ApiError } from '../../../shared/api-error';
import { AuthApi } from '../../auth.api';
import { AuthFormCardComponent } from '../../components/auth-form-card.component';
import { InlineErrorComponent } from '../../components/inline-error.component';
import { PasswordFieldComponent } from '../../components/password-field.component';
import { AuthLayoutComponent } from '../../layouts/auth-layout.component';

@Component({
selector: 'app-login-page',
standalone: true,
imports: [
NgIf,
ReactiveFormsModule,
MatButtonModule,
MatFormFieldModule,
MatInputModule,
MatSnackBarModule,
RouterLink,
AuthLayoutComponent,
AuthFormCardComponent,
PasswordFieldComponent,
InlineErrorComponent,
],
templateUrl: './login-page.component.html',
styleUrls: ['./login-page.component.scss'],
})
export class LoginPageComponent {
private readonly authApi = inject(AuthApi);
private readonly router = inject(Router);
private readonly snackBar = inject(MatSnackBar);

readonly form = new FormGroup({
email: new FormControl('', {
nonNullable: true,
validators: [Validators.required, Validators.email],
}),
password: new FormControl('', {
nonNullable: true,
validators: [Validators.required],
}),
});

formError = '';
isSubmitting = false;

async submit(): Promise<void> {
this.formError = '';
this.clearCredentialError();
this.form.markAllAsTouched();

    if (this.form.invalid) {
      return;
    }

    this.isSubmitting = true;

    try {
      await this.authApi.login(this.form.getRawValue());
      this.snackBar.open('Zalogowano pomyslnie.', 'Zamknij', { duration: 2500 });
      await this.router.navigate(['/rooms']);
    } catch (err) {
      if (this.isInvalidCredentials(err)) {
        this.applyCredentialError();
        this.formError = 'Nieprawidlowy email lub haslo.';
      } else {
        this.formError = this.formatError(err);
      }
    } finally {
      this.isSubmitting = false;
    }
}

private isInvalidCredentials(error: unknown): boolean {
if (error instanceof ApiError) {
return error.code === 'UNAUTHORIZED';
}

    if (error instanceof Error) {
      return error.message.toLowerCase().includes('invalid login credentials');
    }

    if (!error || typeof error !== 'object') {
      return false;
    }

    const candidate = error as { code?: string; message?: string };
    if (candidate.code === 'invalid_credentials') {
      return true;
    }

    return candidate.message?.toLowerCase().includes('invalid login credentials') ?? false;
}

private applyCredentialError(): void {
const control = this.form.controls.password;
const errors = control.errors ?? {};

    if (errors['invalidCredentials']) {
      return;
    }

    control.setErrors({ ...errors, invalidCredentials: true });
}

private clearCredentialError(): void {
const control = this.form.controls.password;
const errors = control.errors;

    if (!errors || !errors['invalidCredentials']) {
      return;
    }

    const { invalidCredentials, ...remainingErrors } = errors;
    control.setErrors(Object.keys(remainingErrors).length ? remainingErrors : null);
}

private formatError(error: unknown): string {
if (error instanceof ApiError) {
if (error.code === 'UNAUTHORIZED') {
return 'Nieprawidlowy email lub haslo.';
}

      return error.message;
    }

    if (error instanceof Error) {
      return error.message;
    }

    return 'Wystapil nieznany blad.';
}
}



================================================
FILE: frontend/src/app/auth/pages/register-page/register-page.component.html
================================================
<app-auth-layout>
<app-auth-form-card title="Utworz konto" subtitle="Zaczynamy od adresu email i bezpiecznego hasla.">
<form [formGroup]="form" (ngSubmit)="submit()" class="auth-form">
<mat-form-field appearance="outline">
<mat-label>Email</mat-label>
<input matInput type="email" formControlName="email" autocomplete="email" />
<mat-error
*ngIf="form.controls.email.hasError('required') && form.controls.email.touched"
>
Email jest wymagany.
</mat-error>
<mat-error *ngIf="form.controls.email.hasError('email') && form.controls.email.touched">
Podaj poprawny adres email.
</mat-error>
</mat-form-field>

      <app-password-field
        [control]="form.controls.password"
        label="Haslo"
        autocomplete="new-password"
        hint="Minimum 6 znakow, bez spacji."
      >
        <mat-error
          *ngIf="form.controls.password.hasError('required') && form.controls.password.touched"
        >
          Haslo jest wymagane.
        </mat-error>
      </app-password-field>

      <app-password-field
        [control]="form.controls.confirmPassword"
        label="Powtorz haslo"
        autocomplete="new-password"
      >
        <mat-error
          *ngIf="
            form.controls.confirmPassword.hasError('required') &&
            form.controls.confirmPassword.touched
          "
        >
          Potwierdzenie hasla jest wymagane.
        </mat-error>
        <mat-error
          *ngIf="form.hasError('passwordMismatch') && form.controls.confirmPassword.touched"
        >
          Hasla nie sa takie same.
        </mat-error>
      </app-password-field>

      <app-inline-error [message]="formError"></app-inline-error>

      <button mat-flat-button color="primary" type="submit" [disabled]="isSubmitting">
        Zarejestruj sie
      </button>
    </form>

    <div authCardFooter class="auth-card__footer-content">
      <span>Masz juz konto?</span>
      <a routerLink="/login">Zaloguj sie</a>
    </div>
  </app-auth-form-card>
</app-auth-layout>



================================================
FILE: frontend/src/app/auth/pages/register-page/register-page.component.scss
================================================
.auth-form {
display: grid;
gap: 16px;
}

.auth-form mat-form-field,
.auth-form app-password-field {
width: 100%;
display: block;
}



================================================
FILE: frontend/src/app/auth/pages/register-page/register-page.component.ts
================================================
import { NgIf } from '@angular/common';
import { Component, inject } from '@angular/core';
import {
AbstractControl,
FormControl,
FormGroup,
ReactiveFormsModule,
ValidationErrors,
Validators,
} from '@angular/forms';
import { MatButtonModule } from '@angular/material/button';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { Router, RouterLink } from '@angular/router';
import { ApiError } from '../../../shared/api-error';
import { AuthApi } from '../../auth.api';
import { AuthFormCardComponent } from '../../components/auth-form-card.component';
import { InlineErrorComponent } from '../../components/inline-error.component';
import { PasswordFieldComponent } from '../../components/password-field.component';
import { AuthLayoutComponent } from '../../layouts/auth-layout.component';

const passwordMatchValidator = (control: AbstractControl): ValidationErrors | null => {
const password = control.get('password')?.value;
const confirmPassword = control.get('confirmPassword')?.value;

if (!password || !confirmPassword) {
return null;
}

return password === confirmPassword ? null : { passwordMismatch: true };
};

@Component({
selector: 'app-register-page',
standalone: true,
imports: [
NgIf,
ReactiveFormsModule,
MatButtonModule,
MatFormFieldModule,
MatInputModule,
MatSnackBarModule,
RouterLink,
AuthLayoutComponent,
AuthFormCardComponent,
PasswordFieldComponent,
InlineErrorComponent,
],
templateUrl: './register-page.component.html',
styleUrls: ['./register-page.component.scss'],
})
export class RegisterPageComponent {
private readonly authApi = inject(AuthApi);
private readonly router = inject(Router);
private readonly snackBar = inject(MatSnackBar);

readonly form = new FormGroup(
{
email: new FormControl('', {
nonNullable: true,
validators: [Validators.required, Validators.email],
}),
password: new FormControl('', {
nonNullable: true,
validators: [Validators.required],
}),
confirmPassword: new FormControl('', {
nonNullable: true,
validators: [Validators.required],
}),
},
{ validators: [passwordMatchValidator] }
);

formError = '';
isSubmitting = false;

async submit(): Promise<void> {
this.formError = '';
this.form.markAllAsTouched();

    if (this.form.invalid) {
      return;
    }

    this.isSubmitting = true;

    try {
      const { email, password } = this.form.getRawValue();
      await this.authApi.signUp({ email, password });
      this.snackBar.open('Konto utworzone. Sprawdz email, aby potwierdzic.', 'Zamknij', {
        duration: 4000,
      });
      await this.router.navigate(['/login']);
    } catch (err) {
      this.formError = this.formatError(err);
    } finally {
      this.isSubmitting = false;
    }
}

private formatError(error: unknown): string {
if (error instanceof ApiError) {
return error.message;
}

    if (error instanceof Error) {
      return error.message;
    }

    return 'Wystapil nieznany blad.';
}
}



================================================
FILE: frontend/src/app/auth/pages/reset-password-page/reset-password-page.component.html
================================================
<app-auth-layout>
<app-auth-form-card
title="Ustaw nowe haslo"
subtitle="Wybierz nowe haslo i zatwierdz zmiane."
>
    <form [formGroup]="form" (ngSubmit)="submit()" class="auth-form">
      <app-password-field
        [control]="form.controls.password"
        label="Nowe haslo"
        autocomplete="new-password"
      >
        <mat-error
          *ngIf="form.controls.password.hasError('required') && form.controls.password.touched"
        >
          Haslo jest wymagane.
        </mat-error>
      </app-password-field>

      <app-password-field
        [control]="form.controls.confirmPassword"
        label="Powtorz haslo"
        autocomplete="new-password"
      >
        <mat-error
          *ngIf="
            form.controls.confirmPassword.hasError('required') &&
            form.controls.confirmPassword.touched
          "
        >
          Potwierdzenie hasla jest wymagane.
        </mat-error>
        <mat-error
          *ngIf="form.hasError('passwordMismatch') && form.controls.confirmPassword.touched"
        >
          Hasla nie sa takie same.
        </mat-error>
      </app-password-field>

      <app-inline-error [message]="formError"></app-inline-error>

      <button mat-flat-button color="primary" type="submit" [disabled]="isSubmitting">
        Zapisz nowe haslo
      </button>
    </form>

    <div authCardFooter class="auth-card__footer-content">
      <span>Wrocic do logowania?</span>
      <a routerLink="/login">Zaloguj sie</a>
    </div>
  </app-auth-form-card>
</app-auth-layout>



================================================
FILE: frontend/src/app/auth/pages/reset-password-page/reset-password-page.component.scss
================================================
.auth-form {
display: grid;
gap: 16px;
}

.auth-form mat-form-field,
.auth-form app-password-field {
width: 100%;
display: block;
}



================================================
FILE: frontend/src/app/auth/pages/reset-password-page/reset-password-page.component.ts
================================================
import { NgIf } from '@angular/common';
import { Component, OnInit, inject } from '@angular/core';
import {
AbstractControl,
FormControl,
FormGroup,
ReactiveFormsModule,
ValidationErrors,
Validators,
} from '@angular/forms';
import { MatButtonModule } from '@angular/material/button';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { ActivatedRoute, Router, RouterLink } from '@angular/router';
import { ApiError } from '../../../shared/api-error';
import { SupabaseService } from '../../../../db/supabase.service';
import { AuthApi } from '../../auth.api';
import { AuthFormCardComponent } from '../../components/auth-form-card.component';
import { InlineErrorComponent } from '../../components/inline-error.component';
import { PasswordFieldComponent } from '../../components/password-field.component';
import { AuthLayoutComponent } from '../../layouts/auth-layout.component';

const passwordMatchValidator = (control: AbstractControl): ValidationErrors | null => {
const password = control.get('password')?.value;
const confirmPassword = control.get('confirmPassword')?.value;

if (!password || !confirmPassword) {
return null;
}

return password === confirmPassword ? null : { passwordMismatch: true };
};

@Component({
selector: 'app-reset-password-page',
standalone: true,
imports: [
NgIf,
ReactiveFormsModule,
MatButtonModule,
MatFormFieldModule,
MatSnackBarModule,
RouterLink,
AuthLayoutComponent,
AuthFormCardComponent,
PasswordFieldComponent,
InlineErrorComponent,
],
templateUrl: './reset-password-page.component.html',
styleUrls: ['./reset-password-page.component.scss'],
})
export class ResetPasswordPageComponent implements OnInit {
private readonly authApi = inject(AuthApi);
private readonly router = inject(Router);
private readonly route = inject(ActivatedRoute);
private readonly snackBar = inject(MatSnackBar);
private readonly supabase = inject(SupabaseService);

readonly form = new FormGroup(
{
password: new FormControl('', {
nonNullable: true,
validators: [Validators.required],
}),
confirmPassword: new FormControl('', {
nonNullable: true,
validators: [Validators.required],
}),
},
{ validators: [passwordMatchValidator] }
);

formError = '';
isSubmitting = false;
private accessToken = '';
private refreshToken = '';

async ngOnInit(): Promise<void> {
const fragment = this.route.snapshot.fragment ?? '';
const tokens = parseAuthFragment(fragment);
const queryAccessToken = this.route.snapshot.queryParamMap.get('access_token') ?? '';
const queryRefreshToken = this.route.snapshot.queryParamMap.get('refresh_token') ?? '';

    this.accessToken = tokens.accessToken ?? queryAccessToken;
    this.refreshToken = tokens.refreshToken ?? queryRefreshToken;

    if (!this.accessToken || !this.refreshToken) {
      const code = this.route.snapshot.queryParamMap.get('code');

      if (code) {
        const { data, error } = await this.supabase.getClient().auth.exchangeCodeForSession(code);
        if (!error && data.session) {
          this.accessToken = data.session.access_token;
          this.refreshToken = data.session.refresh_token;
        }
      }
    }

    if (!this.accessToken || !this.refreshToken) {
      const { data } = await this.supabase.getClient().auth.getSession();
      if (data.session) {
        this.accessToken = data.session.access_token;
        this.refreshToken = data.session.refresh_token;
      }
    }

    if (!this.accessToken || !this.refreshToken) {
      this.formError = 'Brakuje tokenu resetu hasla.';
    }
}

async submit(): Promise<void> {
this.formError = '';
this.form.markAllAsTouched();

    if (!this.accessToken || !this.refreshToken) {
      this.formError = 'Brakuje tokenu resetu hasla.';
      return;
    }

    if (this.form.invalid) {
      return;
    }

    this.isSubmitting = true;

    try {
      const { password } = this.form.getRawValue();
      await this.authApi.resetPassword({
        access_token: this.accessToken,
        refresh_token: this.refreshToken,
        password,
      });
      this.snackBar.open('Haslo zostalo zaktualizowane.', 'Zamknij', { duration: 3000 });
      await this.router.navigate(['/login']);
    } catch (err) {
      this.formError = this.formatError(err);
    } finally {
      this.isSubmitting = false;
    }
}

private formatError(error: unknown): string {
if (error instanceof ApiError) {
return error.message;
}

    if (error instanceof Error) {
      return error.message;
    }

    return 'Wystapil nieznany blad.';
}
}

function parseAuthFragment(fragment: string): { accessToken?: string; refreshToken?: string } {
if (!fragment) {
return {};
}

const params = fragment.split('&').reduce<Record<string, string>>((acc, part) => {
const [rawKey, rawValue] = part.split('=');
if (!rawKey || !rawValue) {
return acc;
}

    acc[decodeURIComponent(rawKey)] = decodeURIComponent(rawValue);
    return acc;
}, {});

return {
accessToken: params['access_token'],
refreshToken: params['refresh_token'],
};
}



================================================
FILE: frontend/src/app/furniture/furniture.api.ts
================================================
import { Injectable, inject } from '@angular/core';
import { SupabaseService } from '../../db/supabase.service';
import type {
CreateFurnitureCommand,
CreateFurniturePayload,
FurnitureDto,
FurniturePlacementDto,
FurniturePlacementUpsertRequest,
ListFurnitureQuery,
UpdateFurnitureCommand,
} from './furniture.types';
import { FURNITURE_DTO_SELECT, FURNITURE_PLACEMENT_SELECT } from './furniture.types';
import { ApiError } from '../shared/api-error';
import {
mapCreateFurniturePostgrestError,
mapDeleteFurniturePostgrestError,
mapGetFurniturePostgrestError,
mapFurniturePlacementPostgrestError,
mapListFurniturePostgrestError,
mapUpdateFurniturePostgrestError,
} from './furniture.errors';
import {
validateCreateFurnitureCommand,
validateFurnitureId,
validateFurniturePlacementRequest,
validateListFurnitureQuery,
validateUpdateFurnitureCommand,
} from './furniture.validation';
import { AuthSessionService } from '../auth/auth-session.service';

@Injectable({
providedIn: 'root',
})
export class FurnitureApi {
private readonly supabase = inject(SupabaseService);
private readonly authSession = inject(AuthSessionService);

async listFurniture(query: ListFurnitureQuery): Promise<FurnitureDto[]> {
const validationErrors = validateListFurnitureQuery(query);
if (validationErrors) {
throw ApiError.validation(validationErrors);
}

    const orderBy = query.sort ?? query.orderBy ?? 'created_at';
    const orderDirection = query.order ?? query.orderDirection ?? 'desc';

    let request = this.supabase
      .getClient()
      .from('furniture')
      .select(FURNITURE_DTO_SELECT)
      .eq('room_id', query.roomId)
      .order(orderBy, { ascending: orderDirection === 'asc' });

    if (query.name) {
      request = request.ilike('name', `%${query.name.trim()}%`);
    }

    if (query.limit !== undefined) {
      const start = query.offset ?? 0;
      const end = start + query.limit - 1;
      request = request.range(start, end);
    }

    const { data, error, status } = await request;

    if (error) {
      throw mapListFurniturePostgrestError(error, status);
    }

    return data ?? [];
}

async getFurniture(furnitureId: string): Promise<FurnitureDto> {
const idErrors = validateFurnitureId(furnitureId);
if (idErrors) {
throw ApiError.validation(idErrors);
}

    const { data, error, status } = await this.supabase
      .getClient()
      .from('furniture')
      .select(FURNITURE_DTO_SELECT)
      .eq('id', furnitureId)
      .maybeSingle();

    if (error) {
      throw mapGetFurniturePostgrestError(error, status);
    }

    if (!data) {
      throw ApiError.notFound('Furniture not found');
    }

    return data;
}

async createFurniture(command: CreateFurnitureCommand): Promise<FurnitureDto> {
const validationErrors = validateCreateFurnitureCommand(command);
if (validationErrors) {
throw ApiError.validation(validationErrors);
}

    const userId = this.authSession.getUserIdOrThrow();
    const payload: CreateFurniturePayload = {
      user_id: userId,
      created_by: userId,
      ...command,
    };

    const { data, error, status } = await this.supabase
      .getClient()
      .from('furniture')
      .insert(payload)
      .select(FURNITURE_DTO_SELECT)
      .single();

    if (error) {
      throw mapCreateFurniturePostgrestError(error, status);
    }

    return data;
}

async updateFurniture(furnitureId: string, command: UpdateFurnitureCommand): Promise<FurnitureDto> {
const idErrors = validateFurnitureId(furnitureId);
if (idErrors) {
throw ApiError.validation(idErrors);
}

    const validationErrors = validateUpdateFurnitureCommand(command);
    if (validationErrors) {
      throw ApiError.validation(validationErrors);
    }

    const { data, error, status } = await this.supabase
      .getClient()
      .from('furniture')
      .update(command)
      .eq('id', furnitureId)
      .select(FURNITURE_DTO_SELECT)
      .single();

    if (error) {
      throw mapUpdateFurniturePostgrestError(error, status);
    }

    return data;
}

async deleteFurniture(furnitureId: string): Promise<void> {
const idErrors = validateFurnitureId(furnitureId);
if (idErrors) {
throw ApiError.validation(idErrors);
}

    const { data, error, status } = await this.supabase
      .getClient()
      .from('furniture')
      .delete()
      .eq('id', furnitureId)
      .select('id')
      .maybeSingle();

    if (error) {
      throw mapDeleteFurniturePostgrestError(error, status);
    }

    if (!data) {
      throw ApiError.notFound('Furniture not found');
    }
}

async getFurniturePlacement(furnitureId: string): Promise<FurniturePlacementDto> {
const idErrors = validateFurnitureId(furnitureId);
if (idErrors) {
throw ApiError.validation(idErrors);
}

    const { data, error, status } = await this.supabase
      .getClient()
      .from('furniture_placements')
      .select(FURNITURE_PLACEMENT_SELECT)
      .eq('furniture_id', furnitureId)
      .maybeSingle();

    if (error) {
      throw mapFurniturePlacementPostgrestError(error, status);
    }

    if (!data) {
      throw ApiError.notFound('Furniture placement not found');
    }

    return data;
}

async upsertFurniturePlacement(
furnitureId: string,
request: FurniturePlacementUpsertRequest
): Promise<FurniturePlacementDto> {
const idErrors = validateFurnitureId(furnitureId);
if (idErrors) {
throw ApiError.validation(idErrors);
}

    const validationErrors = validateFurniturePlacementRequest(request);
    if (validationErrors) {
      throw ApiError.validation(validationErrors);
    }

    const payload = {
      furniture_id: furnitureId,
      ...request,
    };

    const { data, error, status } = await this.supabase
      .getClient()
      .from('furniture_placements')
      .upsert(payload, { onConflict: 'furniture_id' })
      .select(FURNITURE_PLACEMENT_SELECT)
      .single();

    if (error) {
      throw mapFurniturePlacementPostgrestError(error, status);
    }

    return data;
}
}



================================================
FILE: frontend/src/app/furniture/furniture.errors.ts
================================================
import type { PostgrestError } from '@supabase/postgrest-js';
import { ApiError } from '../shared/api-error';

const NOT_FOUND_STATUS = 404;
const NO_ROWS_STATUS = 406;
const NO_ROWS_CODE = 'PGRST116';

function isNotFoundError(error: PostgrestError, status?: number): boolean {
return status === NOT_FOUND_STATUS || status === NO_ROWS_STATUS || error.code === NO_ROWS_CODE;
}

export function mapCreateFurniturePostgrestError(error: PostgrestError, status?: number): ApiError {
if (status === 401) {
return ApiError.unauthorized(error.message);
}

if (error.code === '23505') {
return ApiError.conflict('Furniture name already exists', undefined, error);
}

if (error.code === '23514' || error.code === '23502') {
return ApiError.constraint(error.message, undefined, error);
}

if (error.code === '22P02') {
return ApiError.badRequest(error.message, undefined, error);
}

return new ApiError({
status: status ?? 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}

export function mapListFurniturePostgrestError(error: PostgrestError, status?: number): ApiError {
if (status === 401) {
return ApiError.unauthorized(error.message);
}

if (status === 400 || error.code === '22P02') {
return ApiError.badRequest(error.message, undefined, error);
}

return new ApiError({
status: status ?? 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}

export function mapGetFurniturePostgrestError(error: PostgrestError, status?: number): ApiError {
if (status === 401) {
return ApiError.unauthorized(error.message);
}

if (isNotFoundError(error, status)) {
return ApiError.notFound('Furniture not found');
}

if (status === 400 || error.code === '22P02') {
return ApiError.badRequest(error.message, undefined, error);
}

return new ApiError({
status: status ?? 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}

export function mapUpdateFurniturePostgrestError(error: PostgrestError, status?: number): ApiError {
if (status === 401) {
return ApiError.unauthorized(error.message);
}

if (isNotFoundError(error, status)) {
return ApiError.notFound('Furniture not found');
}

if (error.code === '23505') {
return ApiError.conflict('Furniture name already exists', undefined, error);
}

if (error.code === '23514' || error.code === '23502') {
return ApiError.constraint(error.message, undefined, error);
}

if (error.code === '22P02') {
return ApiError.badRequest(error.message, undefined, error);
}

return new ApiError({
status: status ?? 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}

export function mapDeleteFurniturePostgrestError(error: PostgrestError, status?: number): ApiError {
if (status === 401) {
return ApiError.unauthorized(error.message);
}

if (isNotFoundError(error, status)) {
return ApiError.notFound('Furniture not found');
}

if (status === 400 || error.code === '22P02') {
return ApiError.badRequest(error.message, undefined, error);
}

return new ApiError({
status: status ?? 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}

export function mapFurniturePlacementPostgrestError(
error: PostgrestError,
status?: number
): ApiError {
if (status === 401) {
return ApiError.unauthorized(error.message);
}

if (isNotFoundError(error, status)) {
return ApiError.notFound('Furniture placement not found');
}

if (error.code === '23514' || error.code === '23502') {
return ApiError.constraint(error.message, undefined, error);
}

if (status === 400 || error.code === '22P02') {
return ApiError.badRequest(error.message, undefined, error);
}

return new ApiError({
status: status ?? 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}



================================================
FILE: frontend/src/app/furniture/furniture.types.ts
================================================
import type { Tables, TablesInsert, TablesUpdate } from '../../db/database.types';
import type { UUID } from '../rooms/rooms.types';

export type FurnitureRow = Tables<'furniture'>;
export type FurnitureInsert = TablesInsert<'furniture'>;
export type FurnitureUpdate = TablesUpdate<'furniture'>;
export type FurniturePlacementRow = Tables<'furniture_placements'>;

export type FurnitureDto = Pick<
FurnitureRow,
'id' | 'room_id' | 'name' | 'description' | 'color' | 'created_at' | 'updated_at'
>;

export type FurnitureOrderBy = 'created_at' | 'name';
export type FurnitureOrderDirection = 'asc' | 'desc';

export type ListFurnitureQuery = {
roomId: UUID;
name?: string;
limit?: number;
offset?: number;
sort?: FurnitureOrderBy;
order?: FurnitureOrderDirection;
orderBy?: FurnitureOrderBy;
orderDirection?: FurnitureOrderDirection;
};

export type CreateFurnitureCommand = Pick<FurnitureRow, 'room_id' | 'name' | 'description' | 'color'>;

export type CreateFurniturePayload = CreateFurnitureCommand &
Pick<FurnitureInsert, 'user_id' | 'created_by'>;

export type UpdateFurnitureCommand = Partial<Pick<FurnitureRow, 'name' | 'description' | 'color'>>;

export type UpdateFurniturePayload = UpdateFurnitureCommand & FurnitureUpdate;

export const FURNITURE_DTO_SELECT =
'id,room_id,name,description,color,created_at,updated_at' as const;

export type FurniturePlacementDto = FurniturePlacementRow;

export type FurniturePlacementUpsertRequest = Omit<FurniturePlacementRow, 'furniture_id'>;

export const FURNITURE_PLACEMENT_SELECT =
'furniture_id,room_id,x,y,width_cells,height_cells' as const;



================================================
FILE: frontend/src/app/furniture/furniture.validation.ts
================================================
import type {
CreateFurnitureCommand,
FurniturePlacementUpsertRequest,
ListFurnitureQuery,
UpdateFurnitureCommand,
} from './furniture.types';

const HEX_COLOR_RE = /^#[0-9a-fA-F]{6}$/;

const MAX_NAME_LENGTH = 150;
const MAX_DESCRIPTION_LENGTH = 500;

type CreateFurnitureField = keyof CreateFurnitureCommand;
type FurniturePlacementField = keyof FurniturePlacementUpsertRequest;
type ListFurnitureField = keyof ListFurnitureQuery;
type UpdateFurnitureField = keyof UpdateFurnitureCommand;

function isInteger(value: unknown): value is number {
return typeof value === 'number' && Number.isInteger(value);
}

export function validateCreateFurnitureCommand(
command: CreateFurnitureCommand
): Record<string, string> | null {
const errors: Partial<Record<CreateFurnitureField, string>> = {};

const trimmedName = command.name.trim();
if (trimmedName.length === 0) {
errors.name = 'Name is required';
} else if (trimmedName.length > MAX_NAME_LENGTH) {
errors.name = `Name must be at most ${MAX_NAME_LENGTH} characters`;
}

if (command.description !== null && command.description !== undefined) {
if (command.description.length > MAX_DESCRIPTION_LENGTH) {
errors.description = `Description must be at most ${MAX_DESCRIPTION_LENGTH} characters`;
}
}

if (!HEX_COLOR_RE.test(command.color)) {
errors.color = 'Color must be a hex value like #aabbcc';
}

if (command.room_id.trim().length === 0) {
errors.room_id = 'Room id is required';
}

if (Object.keys(errors).length === 0) {
return null;
}

return errors as Record<string, string>;
}

export function validateUpdateFurnitureCommand(
command: UpdateFurnitureCommand
): Record<string, string> | null {
const errors: Partial<Record<UpdateFurnitureField, string>> = {};

if (command.name !== undefined) {
const trimmedName = command.name.trim();
if (trimmedName.length === 0) {
errors.name = 'Name is required';
} else if (trimmedName.length > MAX_NAME_LENGTH) {
errors.name = `Name must be at most ${MAX_NAME_LENGTH} characters`;
}
}

if (command.description !== undefined) {
if (command.description !== null && command.description.length > MAX_DESCRIPTION_LENGTH) {
errors.description = `Description must be at most ${MAX_DESCRIPTION_LENGTH} characters`;
}
}

if (command.color !== undefined && !HEX_COLOR_RE.test(command.color)) {
errors.color = 'Color must be a hex value like #aabbcc';
}

if (Object.keys(command).length === 0) {
errors.name = 'At least one field must be provided';
}

if (Object.keys(errors).length === 0) {
return null;
}

return errors as Record<string, string>;
}

export function validateListFurnitureQuery(
query: ListFurnitureQuery
): Record<string, string> | null {
const errors: Partial<Record<ListFurnitureField, string>> = {};

if (query.roomId.trim().length === 0) {
errors.roomId = 'Room id is required';
}

if (typeof query.name === 'string') {
const trimmedName = query.name.trim();
if (trimmedName.length === 0) {
errors.name = 'Name filter cannot be empty';
} else if (trimmedName.length > MAX_NAME_LENGTH) {
errors.name = `Name filter must be at most ${MAX_NAME_LENGTH} characters`;
}
}

if (query.limit !== undefined) {
if (!Number.isInteger(query.limit) || query.limit < 1 || query.limit > 200) {
errors.limit = 'limit must be an integer between 1 and 200';
}
}

if (query.offset !== undefined) {
if (!Number.isInteger(query.offset) || query.offset < 0) {
errors.offset = 'offset must be an integer >= 0';
} else if (query.limit === undefined) {
errors.offset = 'offset requires limit to be set';
}
}

if (query.sort !== undefined && query.sort !== 'created_at' && query.sort !== 'name') {
errors.sort = 'sort must be one of: created_at, name';
}

if (query.order !== undefined && query.order !== 'asc' && query.order !== 'desc') {
errors.order = 'order must be one of: asc, desc';
}

if (query.orderBy !== undefined && query.orderBy !== 'created_at' && query.orderBy !== 'name') {
errors.orderBy = 'orderBy must be one of: created_at, name';
}

if (
query.orderDirection !== undefined &&
query.orderDirection !== 'asc' &&
query.orderDirection !== 'desc'
) {
errors.orderDirection = 'orderDirection must be one of: asc, desc';
}

if (Object.keys(errors).length === 0) {
return null;
}

return errors as Record<string, string>;
}

export function validateFurnitureId(furnitureId: string): Record<string, string> | null {
if (furnitureId.trim().length === 0) {
return { furnitureId: 'Furniture id is required' };
}

return null;
}

export function validateFurniturePlacementRequest(
request: FurniturePlacementUpsertRequest
): Record<string, string> | null {
const errors: Partial<Record<FurniturePlacementField, string>> = {};

if (request.room_id.trim().length === 0) {
errors.room_id = 'Room id is required';
}

if (!isInteger(request.x) || request.x < 0 || request.x > 49) {
errors.x = 'x must be an integer between 0 and 49';
}

if (!isInteger(request.y) || request.y < 0 || request.y > 49) {
errors.y = 'y must be an integer between 0 and 49';
}

if (!isInteger(request.width_cells) || request.width_cells < 1 || request.width_cells > 50) {
errors.width_cells = 'width_cells must be an integer between 1 and 50';
}

if (!isInteger(request.height_cells) || request.height_cells < 1 || request.height_cells > 50) {
errors.height_cells = 'height_cells must be an integer between 1 and 50';
}

if (Object.keys(errors).length === 0) {
return null;
}

return errors as Record<string, string>;
}



================================================
FILE: frontend/src/app/furniture/furniture.view-models.ts
================================================
import type { FurnitureDto } from './furniture.types';
import type { UUID } from '../rooms/rooms.types';

export type FurnitureListItemVM = {
id: UUID;
name: string;
description: string | null;
color: string;
updatedAt: string;
};

export function mapFurnitureToListItem(dto: FurnitureDto): FurnitureListItemVM {
return {
id: dto.id,
name: dto.name,
description: dto.description,
color: dto.color,
updatedAt: dto.updated_at,
};
}



================================================
FILE: frontend/src/app/furniture/components/furniture-card.component.ts
================================================
import { DatePipe, NgIf } from '@angular/common';
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import type { FurnitureListItemVM } from '../furniture.view-models';

@Component({
selector: 'app-furniture-card',
standalone: true,
imports: [MatCardModule, MatButtonModule, DatePipe, NgIf],
template: `
    <mat-card
      class="furniture-card"
      [class.furniture-card--highlighted]="highlighted"
      (mouseenter)="hover.emit(item.id)"
      (mouseleave)="hover.emit(null)"
    >
      <div class="furniture-card__row">
        <div
          class="furniture-card__color"
          [style.backgroundColor]="item.color"
          aria-hidden="true"
        ></div>
        <div class="furniture-card__text" (click)="open.emit(item.id)">
          <div class="furniture-card__header">
            <h3>{{ item.name }}</h3>
            <span class="furniture-card__meta"
              >Aktualizacja: {{ item.updatedAt | date: 'mediumDate' }}</span
            >
          </div>
          <p *ngIf="item.description">{{ item.description }}</p>
        </div>
        <div class="furniture-card__actions">
          <button
            mat-stroked-button
            color="primary"
            type="button"
            (click)="handleEdit($event)"
            aria-label="Edytuj mebel"
          >
            Edytuj
          </button>
          <button
            mat-stroked-button
            color="warn"
            type="button"
            (click)="handleDelete($event)"
            aria-label="Usun mebel"
          >
            Usun
          </button>
        </div>
      </div>
    </mat-card>
  `,
styles: [
`
.furniture-card {
display: grid;
padding: 12px 16px;
border-left: 4px solid transparent;
}

      .furniture-card--highlighted {
        border-left-color: #2e7d32;
        background: rgba(46, 125, 50, 0.12);
      }


      .furniture-card__row {
        display: grid;
        grid-template-columns: 12px minmax(0, 1fr) auto;
        gap: 16px;
        align-items: start;
      }

      .furniture-card__color {
        width: 12px;
        min-height: 36px;
        border: 1px solid rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        align-self: stretch;
      }

      .furniture-card__text {
        min-width: 0;
        cursor: pointer;
      }

      .furniture-card__header {
        display: flex;
        align-items: baseline;
        gap: 12px;
        flex-wrap: wrap;
      }

      .furniture-card__header h3 {
        margin: 0 0 4px;
      }

      .furniture-card__header p {
        margin: 0;
        color: rgba(0, 0, 0, 0.6);
        word-break: break-word;
      }

      .furniture-card__meta {
        font-size: 0.85rem;
        color: rgba(0, 0, 0, 0.6);
        white-space: nowrap;
      }

      .furniture-card__actions {
        display: flex;
        gap: 8px;
        justify-self: end;
      }

    `,
],
})
export class FurnitureCardComponent {
@Input({ required: true }) item!: FurnitureListItemVM;
@Input() highlighted = false;
@Output() open = new EventEmitter<string>();
@Output() edit = new EventEmitter<string>();
@Output() delete = new EventEmitter<string>();
@Output() hover = new EventEmitter<string | null>();

handleEdit(event: MouseEvent): void {
event.stopPropagation();
this.edit.emit(this.item.id);
}

handleDelete(event: MouseEvent): void {
event.stopPropagation();
this.delete.emit(this.item.id);
}
}



================================================
FILE: frontend/src/app/furniture/components/furniture-form-dialog.component.ts
================================================
import { NgFor, NgIf } from '@angular/common';
import { Component, Inject, inject } from '@angular/core';
import { FormControl, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { MatButtonModule } from '@angular/material/button';
import { MatDialogModule, MAT_DIALOG_DATA, MatDialogRef } from '@angular/material/dialog';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { RoomGridEditorComponent } from '../../rooms/components/room-grid-editor.component';
import {
RoomGridEditorService,
type RoomGridCell,
type RoomGridState,
} from '../../rooms/room-grid-editor.service';
import type { RoomCellDto } from '../../rooms/rooms.types';
import type { FurniturePlacementUpsertRequest } from '../furniture.types';

export type FurnitureFormValue = {
name: string;
description: string;
color: string;
};

export type FurnitureFormResult = FurnitureFormValue & {
placement?: FurniturePlacementUpsertRequest;
};

export type FurnitureFormDialogData = {
title: string;
submitLabel: string;
value?: FurnitureFormValue;
roomId?: string;
roomCells?: RoomCellDto[];
placement?: FurniturePlacementUpsertRequest;
};

@Component({
selector: 'app-furniture-form-dialog',
standalone: true,
imports: [
NgFor,
NgIf,
MatDialogModule,
MatButtonModule,
MatFormFieldModule,
MatInputModule,
ReactiveFormsModule,
RoomGridEditorComponent,
],
template: `
<h2 mat-dialog-title>{{ data.title }}</h2>
<form [formGroup]="form" (ngSubmit)="submit()" mat-dialog-content class="furniture-form">
<div class="furniture-form__fields">
<mat-form-field appearance="outline" class="field">
<mat-label>Nazwa mebla</mat-label>
<input matInput formControlName="name" maxlength="150" />
<mat-error *ngIf="form.controls.name.hasError('required')">Nazwa jest wymagana.</mat-error>
<mat-error *ngIf="form.controls.name.hasError('maxlength')">
Maksymalnie 150 znakow.
</mat-error>
</mat-form-field>

        <mat-form-field appearance="outline" class="field">
          <mat-label>Opis</mat-label>
          <textarea matInput rows="3" formControlName="description" maxlength="500"></textarea>
          <mat-hint align="end">{{ form.controls.description.value.length }}/500</mat-hint>
        </mat-form-field>

        <section class="color-picker">
          <div class="color-picker__label">Kolor</div>
          <div class="color-picker__swatches">
            <button
              *ngFor="let color of palette; trackBy: trackByColor"
              type="button"
              class="color-picker__swatch"
              [style.backgroundColor]="color"
              [class.color-picker__swatch--selected]="form.controls.color.value === color"
              (click)="selectColor(color)"
              [attr.aria-label]="'Kolor ' + color"
            ></button>
          </div>
          <p class="color-picker__error" *ngIf="form.controls.color.hasError('required')">
            Kolor jest wymagany.
          </p>
        </section>
      </div>

      <section class="placement" *ngIf="gridState">
        <h3>Ustawienie mebla</h3>
        <p class="placement__hint">Zaznacz obszar, na ktorym ma stanac mebel.</p>
        <app-room-grid-editor
          [grid]="gridState"
          [fillColor]="form.controls.color.value"
          [brushSize]="1"
          (setCell)="setCell($event)"
        ></app-room-grid-editor>
        <p class="placement__error" *ngIf="placementError">{{ placementError }}</p>
      </section>
    </form>
    <mat-dialog-actions align="end">
      <button mat-button mat-dialog-close type="button">Anuluj</button>
      <button mat-flat-button color="primary" type="button" [disabled]="form.invalid" (click)="submit()">
        {{ data.submitLabel }}
      </button>
    </mat-dialog-actions>
`,
  styles: [
    `
.field {
width: 100%;
}

      .furniture-form {
        display: grid;
        gap: 16px;
        min-width: 320px;
      }

      .furniture-form__fields {
        display: grid;
        gap: 12px;
      }

      @media (min-width: 720px) {
        .furniture-form {
          grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
          align-items: start;
        }

        .placement {
          margin-top: 0;
        }
      }

      .placement {
        display: grid;
        gap: 12px;
        margin-top: 8px;
        padding: 12px;
        border-radius: 12px;
        background: #f7f7f7;
      }

      .placement h3 {
        margin: 0;
      }

      .placement__hint {
        margin: 0;
        color: rgba(0, 0, 0, 0.6);
      }

      .placement__error {
        margin: 0;
        padding: 10px 12px;
        border-radius: 12px;
        background: #fff4f4;
        color: #8a2f2f;
        border: 1px solid #f2c6c6;
      }

      .color-picker {
        display: grid;
        gap: 8px;
      }

      .color-picker__label {
        font-weight: 500;
      }

      .color-picker__swatches {
        display: grid;
        grid-template-columns: repeat(5, 36px);
        gap: 8px;
      }

      .color-picker__swatch {
        width: 36px;
        height: 36px;
        border-radius: 10px;
        border: 2px solid transparent;
        cursor: pointer;
      }

      .color-picker__swatch--selected {
        border-color: rgba(0, 0, 0, 0.7);
      }

      .color-picker__error {
        margin: 0;
        font-size: 0.85rem;
        color: #8a2f2f;
      }
    `,
],
})
export class FurnitureFormDialogComponent {
private readonly gridService = inject(RoomGridEditorService);
private gridOffset = { x: 0, y: 0 };

readonly form: FormGroup<{
name: FormControl<string>;
description: FormControl<string>;
color: FormControl<string>;
}>;

readonly palette = [
'#ff1744',
'#ff6d00',
'#ffea00',
'#00c853',
'#00bfa5',
'#00b0ff',
'#2962ff',
'#651fff',
'#c51162',
'#4e342e',
];

gridState: RoomGridState | null = null;
placementError: string | null = null;

constructor(
@Inject(MAT_DIALOG_DATA) readonly data: FurnitureFormDialogData,
private readonly dialogRef: MatDialogRef<FurnitureFormDialogComponent, FurnitureFormResult>
) {
const initialColor = this.normalizeColor(this.data.value?.color);
this.form = new FormGroup({
name: new FormControl(this.data.value?.name ?? '', {
nonNullable: true,
validators: [Validators.required, Validators.maxLength(150)],
}),
description: new FormControl(this.data.value?.description ?? '', {
nonNullable: true,
validators: [Validators.maxLength(500)],
}),
color: new FormControl(initialColor, {
nonNullable: true,
validators: [Validators.required],
}),
});

    if (this.data.roomCells && this.data.roomCells.length > 0) {
      const bounds = this.getRoomCellsBounds(this.data.roomCells);
      if (bounds) {
        const widthWithPadding = bounds.width + 4;
        const heightWithPadding = bounds.height + 4;
        this.gridOffset = {
          x: 2 - bounds.minX,
          y: 2 - bounds.minY,
        };

        const grid = this.gridService.createGrid(widthWithPadding, heightWithPadding, false);
        const shiftedCells = this.data.roomCells.map((cell) => ({
          x: cell.x + this.gridOffset.x,
          y: cell.y + this.gridOffset.y,
        }));
        this.gridState = this.gridService.applyAllowedCells(grid, shiftedCells);
        if (this.data.placement) {
          this.gridService.fillRectangle(this.gridState, {
            xStart: this.data.placement.x + this.gridOffset.x,
            yStart: this.data.placement.y + this.gridOffset.y,
            widthCells: this.data.placement.width_cells,
            heightCells: this.data.placement.height_cells,
          });
        }
      }
    }
}

setCell(payload: { cell: RoomGridCell; filled: boolean }): void {
if (!this.gridState) {
return;
}
const { cell, filled } = payload;
this.gridState = this.gridService.setCell(this.gridState, cell, filled);
}

submit(): void {
this.placementError = null;
if (this.form.invalid) {
this.form.markAllAsTouched();
return;
}

    const value = this.form.getRawValue();

    if (this.gridState) {
      const bounds = this.gridService.getBounds(this.gridState);
      if (!bounds || !this.data.roomId) {
        this.placementError = 'Wybierz miejsce dla mebla.';
        return;
      }

      this.dialogRef.close({
        ...value,
        placement: {
          room_id: this.data.roomId,
          x: bounds.xStart - this.gridOffset.x,
          y: bounds.yStart - this.gridOffset.y,
          width_cells: bounds.widthCells,
          height_cells: bounds.heightCells,
        },
      });
      return;
    }

    this.dialogRef.close(value);
}

selectColor(color: string): void {
this.form.controls.color.setValue(color);
}

trackByColor(_: number, color: string): string {
return color;
}

private normalizeColor(color?: string): string {
if (color && this.palette.includes(color)) {
return color;
}
return this.palette[0];
}

private getRoomCellsBounds(
cells: RoomCellDto[]
): { minX: number; minY: number; width: number; height: number } | null {
if (cells.length === 0) {
return null;
}

    const xs = cells.map((cell) => cell.x);
    const ys = cells.map((cell) => cell.y);
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);

    return {
      minX,
      minY,
      width: maxX - minX + 1,
      height: maxY - minY + 1,
    };
}
}



================================================
FILE: frontend/src/app/furniture/components/furniture-list.component.ts
================================================
import { NgFor } from '@angular/common';
import { Component, EventEmitter, Input, Output } from '@angular/core';
import type { FurnitureListItemVM } from '../furniture.view-models';
import { FurnitureCardComponent } from './furniture-card.component';

@Component({
selector: 'app-furniture-list',
standalone: true,
imports: [NgFor, FurnitureCardComponent],
template: `
    <section class="furniture-list" aria-label="Lista mebli">
      <app-furniture-card
        *ngFor="let item of items; trackBy: trackByFurnitureId"
        [item]="item"
        [highlighted]="item.id === highlightedId"
        (open)="open.emit($event)"
        (edit)="edit.emit($event)"
        (delete)="delete.emit($event)"
        (hover)="hover.emit($event)"
      />
    </section>
  `,
styles: [
`
      .furniture-list {
        display: grid;
        gap: 16px;
      }
    `,
],
})
export class FurnitureListComponent {
@Input({ required: true }) items: FurnitureListItemVM[] = [];
@Input() highlightedId?: string;
@Output() open = new EventEmitter<string>();
@Output() edit = new EventEmitter<string>();
@Output() delete = new EventEmitter<string>();
@Output() hover = new EventEmitter<string | null>();

trackByFurnitureId(index: number, item: FurnitureListItemVM): string {
return item.id;
}
}



================================================
FILE: frontend/src/app/items/items.api.ts
================================================
import { Injectable, inject } from '@angular/core';
import { SupabaseService } from '../../db/supabase.service';
import { ApiError } from '../shared/api-error';
import {
mapCreateItemsPostgrestError,
mapDeleteItemPostgrestError,
mapListItemsPostgrestError,
} from './items.errors';
import type {
ItemCreateFailureDto,
ItemCreateRequest,
ItemCreateResponseDto,
ItemListItemDto,
ItemListResponseDto,
ListFurnitureItemsQuery,
} from './items.types';
import { ITEM_LIST_SELECT } from './items.types';
import {
validateCreateItemsRequest,
validateFurnitureId,
validateItemId,
validateListFurnitureItemsQuery,
} from './items.validation';
import { AuthSessionService } from '../auth/auth-session.service';

@Injectable({
providedIn: 'root',
})
export class ItemsApi {
private readonly supabase = inject(SupabaseService);
private readonly authSession = inject(AuthSessionService);

async listFurnitureItems(query: ListFurnitureItemsQuery): Promise<ItemListResponseDto> {
const validationErrors = validateListFurnitureItemsQuery(query);
if (validationErrors) {
throw ApiError.validation(validationErrors);
}

    const orderBy = query.sort ?? query.orderBy ?? 'created_at';
    const orderDirection = query.order ?? query.orderDirection ?? 'desc';

    let request = this.supabase
      .getClient()
      .from('items')
      .select(ITEM_LIST_SELECT)
      .eq('furniture_id', query.furnitureId)
      .order(orderBy, { ascending: orderDirection === 'asc' });

    if (query.q) {
      request = request.ilike('name', `%${query.q.trim()}%`);
    }

    if (query.limit !== undefined) {
      const start = query.offset ?? 0;
      const end = start + query.limit - 1;
      request = request.range(start, end);
    }

    const { data, error, status } = await request;

    if (error) {
      throw mapListItemsPostgrestError(error, status);
    }

    return { data: data ?? [] };
}

async createFurnitureItems(
furnitureId: string,
request: ItemCreateRequest
): Promise<ItemCreateResponseDto> {
const idErrors = validateFurnitureId(furnitureId);
if (idErrors) {
throw ApiError.validation(idErrors);
}

    const validationErrors = validateCreateItemsRequest(request);
    if (validationErrors) {
      throw ApiError.validation(validationErrors);
    }

    const created: ItemListItemDto[] = [];
    const failed: ItemCreateFailureDto[] = [];
    const userId = this.authSession.getUserIdOrThrow();

    for (const item of request.items) {
      const payload = {
        furniture_id: furnitureId,
        name: item.name.trim(),
        user_id: userId,
        created_by: userId,
      };

      const { data, error, status } = await this.supabase
        .getClient()
        .from('items')
        .insert(payload)
        .select(ITEM_LIST_SELECT)
        .single();

      if (error) {
        const mapped = mapCreateItemsPostgrestError(error, status);
        if (mapped.status === 401) {
          throw mapped;
        }
        failed.push({ name: item.name, error: mapped.message });
        continue;
      }

      if (data) {
        created.push(data);
      }
    }

    return { created, failed };
}

async deleteItem(itemId: string): Promise<void> {
const idErrors = validateItemId(itemId);
if (idErrors) {
throw ApiError.validation(idErrors);
}

    const { data, error, status } = await this.supabase
      .getClient()
      .from('items')
      .delete()
      .eq('id', itemId)
      .select('id')
      .maybeSingle();

    if (error) {
      throw mapDeleteItemPostgrestError(error, status);
    }

    if (!data) {
      throw ApiError.notFound('Item not found');
    }
}
}



================================================
FILE: frontend/src/app/items/items.errors.ts
================================================
import type { PostgrestError } from '@supabase/postgrest-js';
import { ApiError } from '../shared/api-error';

const NOT_FOUND_STATUS = 404;
const NO_ROWS_STATUS = 406;
const NO_ROWS_CODE = 'PGRST116';

function isNotFoundError(error: PostgrestError, status?: number): boolean {
return status === NOT_FOUND_STATUS || status === NO_ROWS_STATUS || error.code === NO_ROWS_CODE;
}

export function mapListItemsPostgrestError(error: PostgrestError, status?: number): ApiError {
if (status === 401) {
return ApiError.unauthorized(error.message);
}

if (status === 400 || error.code === '22P02') {
return ApiError.badRequest(error.message, undefined, error);
}

return new ApiError({
status: status ?? 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}

export function mapCreateItemsPostgrestError(error: PostgrestError, status?: number): ApiError {
if (status === 401) {
return ApiError.unauthorized(error.message);
}

if (error.code === '23514' || error.code === '23502' || error.code === '23503') {
return ApiError.constraint(error.message, undefined, error);
}

if (error.code === '22P02') {
return ApiError.badRequest(error.message, undefined, error);
}

return new ApiError({
status: status ?? 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}

export function mapUpdateItemPostgrestError(error: PostgrestError, status?: number): ApiError {
if (status === 401) {
return ApiError.unauthorized(error.message);
}

if (isNotFoundError(error, status)) {
return ApiError.notFound('Item not found');
}

if (error.code === '23514' || error.code === '23502') {
return ApiError.constraint(error.message, undefined, error);
}

if (error.code === '22P02') {
return ApiError.badRequest(error.message, undefined, error);
}

return new ApiError({
status: status ?? 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}

export function mapDeleteItemPostgrestError(error: PostgrestError, status?: number): ApiError {
if (status === 401) {
return ApiError.unauthorized(error.message);
}

if (isNotFoundError(error, status)) {
return ApiError.notFound('Item not found');
}

if (status === 400 || error.code === '22P02') {
return ApiError.badRequest(error.message, undefined, error);
}

return new ApiError({
status: status ?? 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}



================================================
FILE: frontend/src/app/items/items.types.ts
================================================
import type { Tables, TablesInsert, TablesUpdate } from '../../db/database.types';
import type { UUID } from '../rooms/rooms.types';

export type ItemRow = Tables<'items'>;
export type ItemInsert = TablesInsert<'items'>;
export type ItemUpdate = TablesUpdate<'items'>;

export type ItemDto = Pick<ItemRow, 'id' | 'furniture_id' | 'name' | 'created_at' | 'updated_at'>;

export type ItemListItemDto = Pick<ItemRow, 'id' | 'name'>;

export type ItemOrderBy = 'created_at' | 'name';
export type ItemOrderDirection = 'asc' | 'desc';

export type ListFurnitureItemsQuery = {
furnitureId: UUID;
limit?: number;
offset?: number;
sort?: ItemOrderBy;
order?: ItemOrderDirection;
orderBy?: ItemOrderBy;
orderDirection?: ItemOrderDirection;
q?: string;
};

export type ItemListResponseDto = {
data: ItemListItemDto[];
};

export type ItemCreateInput = Pick<ItemRow, 'name'>;

export type ItemCreateRequest = {
items: ItemCreateInput[];
};

export type ItemCreateFailureDto = {
name: ItemRow['name'];
error?: string;
};

export type ItemCreateResponseDto = {
created: ItemListItemDto[];
failed: ItemCreateFailureDto[];
};

export type ItemRenameRequest = Pick<ItemRow, 'name'>;

export type ItemRenameResponseDto = Pick<ItemRow, 'id' | 'name' | 'updated_at'>;

export const ITEM_LIST_SELECT = 'id,name' as const;
export const ITEM_RENAME_SELECT = 'id,name,updated_at' as const;



================================================
FILE: frontend/src/app/items/items.validation.ts
================================================
import type {
ItemCreateRequest,
ItemRenameRequest,
ListFurnitureItemsQuery,
} from './items.types';

const MAX_NAME_LENGTH = 200;

type CreateItemField = `items.${number}.name` | 'items';
type ListItemsField = keyof ListFurnitureItemsQuery;
type RenameItemField = keyof ItemRenameRequest;

function isInteger(value: unknown): value is number {
return typeof value === 'number' && Number.isInteger(value);
}

export function validateFurnitureId(furnitureId: string): Record<string, string> | null {
if (furnitureId.trim().length === 0) {
return { furnitureId: 'Furniture id is required' };
}

return null;
}

export function validateItemId(itemId: string): Record<string, string> | null {
if (itemId.trim().length === 0) {
return { itemId: 'Item id is required' };
}

return null;
}

export function validateListFurnitureItemsQuery(
query: ListFurnitureItemsQuery
): Record<string, string> | null {
const errors: Partial<Record<ListItemsField, string>> = {};

if (query.furnitureId.trim().length === 0) {
errors.furnitureId = 'Furniture id is required';
}

if (typeof query.q === 'string') {
const trimmed = query.q.trim();
if (trimmed.length === 0) {
errors.q = 'Query filter cannot be empty';
} else if (trimmed.length > MAX_NAME_LENGTH) {
errors.q = `Query filter must be at most ${MAX_NAME_LENGTH} characters`;
}
}

if (query.limit !== undefined) {
if (!isInteger(query.limit) || query.limit < 1 || query.limit > 200) {
errors.limit = 'limit must be an integer between 1 and 200';
}
}

if (query.offset !== undefined) {
if (!isInteger(query.offset) || query.offset < 0) {
errors.offset = 'offset must be an integer >= 0';
} else if (query.limit === undefined) {
errors.offset = 'offset requires limit to be set';
}
}

if (query.sort !== undefined && query.sort !== 'created_at' && query.sort !== 'name') {
errors.sort = 'sort must be one of: created_at, name';
}

if (query.order !== undefined && query.order !== 'asc' && query.order !== 'desc') {
errors.order = 'order must be one of: asc, desc';
}

if (query.orderBy !== undefined && query.orderBy !== 'created_at' && query.orderBy !== 'name') {
errors.orderBy = 'orderBy must be one of: created_at, name';
}

if (
query.orderDirection !== undefined &&
query.orderDirection !== 'asc' &&
query.orderDirection !== 'desc'
) {
errors.orderDirection = 'orderDirection must be one of: asc, desc';
}

if (Object.keys(errors).length === 0) {
return null;
}

return errors as Record<string, string>;
}

export function validateCreateItemsRequest(request: ItemCreateRequest): Record<string, string> | null {
const errors: Partial<Record<CreateItemField, string>> = {};

if (!Array.isArray(request.items) || request.items.length === 0) {
errors.items = 'At least one item is required';
return errors as Record<string, string>;
}

request.items.forEach((item, index) => {
const trimmed = item.name.trim();
if (trimmed.length === 0) {
errors[`items.${index}.name`] = 'Name is required';
} else if (trimmed.length > MAX_NAME_LENGTH) {
errors[`items.${index}.name`] = `Name must be at most ${MAX_NAME_LENGTH} characters`;
}
});

if (Object.keys(errors).length === 0) {
return null;
}

return errors as Record<string, string>;
}

export function validateRenameItemRequest(
request: ItemRenameRequest
): Record<string, string> | null {
const errors: Partial<Record<RenameItemField, string>> = {};
const trimmed = request.name.trim();

if (trimmed.length === 0) {
errors.name = 'Name is required';
} else if (trimmed.length > MAX_NAME_LENGTH) {
errors.name = `Name must be at most ${MAX_NAME_LENGTH} characters`;
}

if (Object.keys(errors).length === 0) {
return null;
}

return errors as Record<string, string>;
}



================================================
FILE: frontend/src/app/items/items.view-models.ts
================================================
export type ItemDraftVM = {
id: string;
name: string;
error?: string;
serverError?: string;
};



================================================
FILE: frontend/src/app/items/components/furniture-items-dialog.component.ts
================================================
import { NgIf } from '@angular/common';
import { ChangeDetectorRef, Component, Inject, OnInit, inject } from '@angular/core';
import { MatDialog, MatDialogModule, MAT_DIALOG_DATA, MatDialogRef } from '@angular/material/dialog';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { firstValueFrom } from 'rxjs';
import { ApiError } from '../../shared/api-error';
import { ConfirmDialogComponent } from '../../shared/confirm-dialog/confirm-dialog.component';
import { ItemsApi } from '../items.api';
import type {
ItemCreateResponseDto,
ItemListItemDto,
ItemListResponseDto,
} from '../items.types';
import { ItemsBulkAddFormComponent } from './items-bulk-add-form.component';
import { ItemsDialogActionsComponent } from './items-dialog-actions.component';
import { ItemsListComponent } from './items-list.component';
import type { ItemDraftVM } from '../items.view-models';

export type FurnitureItemsDialogData = {
furnitureId: string;
furnitureName: string;
roomId?: string;
initialItems?: ItemListItemDto[];
};

@Component({
selector: 'app-furniture-items-dialog',
standalone: true,
imports: [
NgIf,
MatDialogModule,
MatSnackBarModule,
ItemsListComponent,
ItemsBulkAddFormComponent,
ItemsDialogActionsComponent,
],
template: `
<h2 mat-dialog-title>Przedmioty: {{ data.furnitureName }}</h2>
<mat-dialog-content class="items-dialog">
<section class="items-dialog__column">
<app-items-bulk-add-form
[drafts]="drafts"
[saving]="isSaving"
(add)="addDraft()"
(remove)="removeDraft($event)"
(update)="updateDraft($event)"
></app-items-bulk-add-form>
</section>

      <section class="items-dialog__column">
        <app-items-list
          [items]="items"
          [isLoading]="isLoading"
          [busyIds]="deleteBusyIds"
          (delete)="confirmDelete($event)"
        ></app-items-list>

        <p class="items-dialog__error" *ngIf="listError">{{ listError }}</p>
      </section>
    </mat-dialog-content>

    <app-items-dialog-actions
      [canSave]="canSave"
      [saving]="isSaving"
      (cancel)="close()"
      (save)="saveDrafts()"
    ></app-items-dialog-actions>
`,
  styles: [
    `
.items-dialog {
display: grid;
grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
gap: 16px;
min-width: 320px;
height: 50vh;
overflow: hidden;
box-sizing: border-box;
}

      .items-dialog__column {
        min-height: 0;
        overflow: auto;
        overflow-x: hidden;
      }

      .items-dialog__error {
        margin: 0;
        padding: 10px 12px;
        border-radius: 12px;
        background: #fff4f4;
        color: #8a2f2f;
        border: 1px solid #f2c6c6;
      }
    `,
],
})
export class FurnitureItemsDialogComponent implements OnInit {
private readonly api = inject(ItemsApi);
private readonly dialog = inject(MatDialog);
private readonly snackBar = inject(MatSnackBar);
private readonly dialogRef = inject(MatDialogRef<FurnitureItemsDialogComponent>);
private readonly cdr = inject(ChangeDetectorRef);

items: ItemListItemDto[] = [];
drafts: ItemDraftVM[] = [this.createDraft()];
isLoading = false;
isSaving = false;
listError: string | null = null;
deleteBusyIds = new Set<string>();
private draftCounter = 0;

constructor(@Inject(MAT_DIALOG_DATA) readonly data: FurnitureItemsDialogData) {
if (data.initialItems) {
this.items = [...data.initialItems];
}
}

get canSave(): boolean {
return this.drafts.length > 0 && this.drafts.every((draft) => this.isDraftValid(draft));
}

async ngOnInit(): Promise<void> {
await this.loadItems();
}

close(): void {
this.dialogRef.close();
}

addDraft(): void {
this.drafts = [...this.drafts, this.createDraft()];
}

removeDraft(id: string): void {
const next = this.drafts.filter((draft) => draft.id !== id);
this.drafts = next.length > 0 ? next : [this.createDraft()];
}

updateDraft(payload: { id: string; name: string }): void {
this.drafts = this.drafts.map((draft) => {
if (draft.id !== payload.id) {
return draft;
}
return { ...draft, name: payload.name, error: undefined, serverError: undefined };
});
}

async saveDrafts(): Promise<void> {
const { validItems, nextDrafts } = this.validateDrafts();
this.drafts = nextDrafts;

    if (validItems.length === 0) {
      return;
    }

    this.isSaving = true;
    try {
      const response = await this.api.createFurnitureItems(this.data.furnitureId, {
        items: validItems,
      });
      this.applyCreateResponse(response);
    } catch (err: unknown) {
      this.showError(err);
    } finally {
      this.isSaving = false;
    }
}

async confirmDelete(itemId: string): Promise<void> {
const dialogRef = this.dialog.open(ConfirmDialogComponent, {
data: {
title: 'Usun przedmiot',
message: 'Czy na pewno chcesz usunac ten przedmiot?',
confirmText: 'Usun',
cancelText: 'Anuluj',
},
});

    const confirmed = await firstValueFrom(dialogRef.afterClosed());
    if (!confirmed) {
      return;
    }

    await this.deleteItem(itemId);
}

private async loadItems(): Promise<void> {
this.isLoading = true;
this.listError = null;
try {
const response: ItemListResponseDto = await this.api.listFurnitureItems({
furnitureId: this.data.furnitureId,
});
this.deferStateUpdate(() => {
this.items = response.data ?? [];
});
} catch (err: unknown) {
this.listError = this.formatError(err);
this.showError(err);
} finally {
this.isLoading = false;
}
}

private async deleteItem(itemId: string): Promise<void> {
if (this.deleteBusyIds.has(itemId)) {
return;
}

    this.deleteBusyIds.add(itemId);
    try {
      await this.api.deleteItem(itemId);
      this.items = this.items.filter((item) => item.id !== itemId);
    } catch (err: unknown) {
      if (err instanceof ApiError && err.status === 404) {
        this.items = this.items.filter((item) => item.id !== itemId);
        this.snackBar.open('Przedmiot juz zostal usuniety.', 'Zamknij', { duration: 3000 });
      } else {
        this.showError(err);
      }
    } finally {
      this.deleteBusyIds.delete(itemId);
    }
}

private validateDrafts(): { validItems: Array<{ name: string }>; nextDrafts: ItemDraftVM[] } {
const validItems: Array<{ name: string }> = [];
const nextDrafts = this.drafts.map((draft) => {
const trimmed = draft.name.trim();
if (trimmed.length === 0) {
return { ...draft, error: 'Nazwa jest wymagana.', serverError: undefined };
}
if (trimmed.length > 200) {
return { ...draft, error: 'Nazwa moze miec maksymalnie 200 znakow.', serverError: undefined };
}
validItems.push({ name: trimmed });
return { ...draft, error: undefined, serverError: undefined };
});

    return { validItems, nextDrafts };
}

private applyCreateResponse(response: ItemCreateResponseDto): void {
this.deferStateUpdate(() => {
if (response.created.length > 0) {
this.items = [...response.created, ...this.items];
}

      let remainingDrafts = [...this.drafts];

      for (const created of response.created) {
        const index = remainingDrafts.findIndex(
          (draft) => draft.name.trim() === created.name.trim()
        );
        if (index !== -1) {
          remainingDrafts.splice(index, 1);
        }
      }

      for (const failed of response.failed) {
        const index = remainingDrafts.findIndex(
          (draft) => draft.name.trim() === failed.name.trim()
        );
        if (index !== -1) {
          remainingDrafts[index] = {
            ...remainingDrafts[index],
            error: undefined,
            serverError: failed.error ?? 'Nie udalo sie zapisac przedmiotu.',
          };
        }
      }

      if (remainingDrafts.length === 0) {
        remainingDrafts = [this.createDraft()];
      }

      this.drafts = remainingDrafts;
    });
}

private createDraft(): ItemDraftVM {
this.draftCounter += 1;
return { id: `draft-${this.draftCounter}`, name: '' };
}

private isDraftValid(draft: ItemDraftVM): boolean {
const trimmed = draft.name.trim();
return (
trimmed.length > 0 &&
trimmed.length <= 200 &&
!draft.error &&
!draft.serverError
);
}

private deferStateUpdate(update: () => void): void {
Promise.resolve().then(() => {
update();
this.cdr.detectChanges();
});
}

private showError(err: unknown): void {
this.snackBar.open(this.formatError(err), 'Zamknij', { duration: 4000 });
}

private formatError(error: unknown): string {
if (error instanceof ApiError) {
if (error.details?.['name']) {
return error.details['name'];
}
return error.message;
}

    if (error instanceof Error) {
      return error.message;
    }

    return 'Wystapil nieznany blad.';
}
}



================================================
FILE: frontend/src/app/items/components/item-row.component.ts
================================================
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import type { ItemListItemDto } from '../items.types';

@Component({
selector: 'app-item-row',
standalone: true,
imports: [MatButtonModule, MatIconModule],
template: `
    <div class="item-row">
      <span class="item-row__name">{{ item.name }}</span>
      <button
        mat-icon-button
        class="item-row__delete"
        type="button"
        (click)="delete.emit(item.id)"
        [disabled]="busy"
        aria-label="Usun przedmiot"
      >
        <mat-icon>close</mat-icon>
      </button>
    </div>
  `,
styles: [
`
.item-row {
display: flex;
align-items: center;
justify-content: space-between;
gap: 12px;
padding: 4px 0;
border-bottom: 1px solid rgba(0, 0, 0, 0.08);
}

      .item-row__name {
        font-size: 0.95rem;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .item-row__delete {
        color: #d32f2f;
        font-size: 1.1rem;
        line-height: 1;
        width: 28px;
        height: 28px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
    `,
],
})
export class ItemRowComponent {
@Input({ required: true }) item!: ItemListItemDto;
@Input() busy = false;
@Output() delete = new EventEmitter<string>();
}



================================================
FILE: frontend/src/app/items/components/items-bulk-add-form.component.ts
================================================
import { NgFor, NgIf } from '@angular/common';
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import type { ItemDraftVM } from '../items.view-models';

@Component({
selector: 'app-items-bulk-add-form',
standalone: true,
imports: [NgFor, NgIf, MatButtonModule, MatFormFieldModule, MatInputModule],
template: `
<section class="items-form">
<header class="items-form__header">
<h3>Dodaj przedmioty</h3>
<button mat-stroked-button type="button" (click)="add.emit()" [disabled]="saving">
+
</button>
</header>

      <div class="items-form__rows">
        <div class="items-form__row" *ngFor="let draft of drafts; trackBy: trackByDraftId">
          <mat-form-field appearance="outline" class="items-form__field">
            <mat-label>Przedmiot</mat-label>
            <input
              matInput
              [value]="draft.name"
              (input)="onInputChange(draft.id, $event)"
              maxlength="200"
            />
            <mat-error *ngIf="draft.error">{{ draft.error }}</mat-error>
            <mat-error *ngIf="!draft.error && draft.serverError">
              {{ draft.serverError }}
            </mat-error>
          </mat-form-field>
          <button
            mat-stroked-button
            color="warn"
            type="button"
            (click)="remove.emit(draft.id)"
            [disabled]="saving || drafts.length === 1"
          >
            Usun
          </button>
        </div>
      </div>
    </section>
`,
  styles: [
    `
.items-form {
display: grid;
gap: 12px;
}

      .items-form__header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .items-form__header h3 {
        margin: 0;
      }

      .items-form__rows {
        display: grid;
        gap: 12px;
      }

      .items-form__row {
        display: grid;
        grid-template-columns: minmax(0, 1fr) auto;
        gap: 12px;
        align-items: start;
      }

      .items-form__field {
        width: 100%;
      }
    `,
],
})
export class ItemsBulkAddFormComponent {
@Input({ required: true }) drafts: ItemDraftVM[] = [];
@Input() saving = false;
@Output() add = new EventEmitter<void>();
@Output() remove = new EventEmitter<string>();
@Output() update = new EventEmitter<{ id: string; name: string }>();

trackByDraftId(_: number, draft: ItemDraftVM): string {
return draft.id;
}

onInputChange(id: string, event: Event): void {
const target = event.target as HTMLInputElement;
this.update.emit({ id, name: target.value });
}
}



================================================
FILE: frontend/src/app/items/components/items-dialog-actions.component.ts
================================================
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';
import { MatDialogModule } from '@angular/material/dialog';

@Component({
selector: 'app-items-dialog-actions',
standalone: true,
imports: [MatDialogModule, MatButtonModule],
template: `
    <mat-dialog-actions align="end">
      <button mat-button type="button" (click)="cancel.emit()" [disabled]="saving">Anuluj</button>
      <button
        mat-flat-button
        color="primary"
        type="button"
        (click)="save.emit()"
        [disabled]="!canSave || saving"
      >
        Zapisz
      </button>
    </mat-dialog-actions>
  `,
})
export class ItemsDialogActionsComponent {
@Input() canSave = false;
@Input() saving = false;
@Output() cancel = new EventEmitter<void>();
@Output() save = new EventEmitter<void>();
}



================================================
FILE: frontend/src/app/items/components/items-list.component.ts
================================================
import { NgFor, NgIf } from '@angular/common';
import { Component, EventEmitter, Input, Output } from '@angular/core';
import type { ItemListItemDto } from '../items.types';
import { ItemRowComponent } from './item-row.component';

@Component({
selector: 'app-items-list',
standalone: true,
imports: [NgFor, NgIf, ItemRowComponent],
template: `
    <section class="items-list" aria-label="Lista przedmiotow">
      <p class="items-list__status" *ngIf="isLoading && items.length === 0">
        Laduje przedmioty...
      </p>
      <p class="items-list__status" *ngIf="!isLoading && items.length === 0">
        Brak przedmiotow.
      </p>
      <app-item-row
        *ngFor="let item of items; trackBy: trackByItemId"
        [item]="item"
        [busy]="busyIds?.has(item.id) ?? false"
        (delete)="delete.emit($event)"
      ></app-item-row>
    </section>
  `,
styles: [
`
.items-list {
display: grid;
gap: 8px;
}

      .items-list__status {
        margin: 0;
        color: rgba(0, 0, 0, 0.6);
      }
    `,
],
})
export class ItemsListComponent {
@Input({ required: true }) items: ItemListItemDto[] = [];
@Input() isLoading = false;
@Input() busyIds?: Set<string>;
@Output() delete = new EventEmitter<string>();

trackByItemId(_: number, item: ItemListItemDto): string {
return item.id;
}
}



================================================
FILE: frontend/src/app/rooms/room-details.facade.ts
================================================
import { Injectable, inject } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { ApiError } from '../shared/api-error';
import { FurnitureApi } from '../furniture/furniture.api';
import type { FurnitureListItemVM } from '../furniture/furniture.view-models';
import { mapFurnitureToListItem } from '../furniture/furniture.view-models';
import type { FurniturePlacementDto, FurniturePlacementUpsertRequest } from '../furniture/furniture.types';
import { RoomsApi } from './rooms.api';
import type { RoomCellDto, RoomDto, UUID } from './rooms.types';

export type RoomDetailsState = {
room: RoomDto | null;
cells: RoomCellDto[];
furniture: FurnitureListItemVM[];
placements: FurniturePlacementVM[];
isLoading: boolean;
error: ApiError | null;
notFound: boolean;
};

const EMPTY_STATE: RoomDetailsState = {
room: null,
cells: [],
furniture: [],
placements: [],
isLoading: false,
error: null,
notFound: false,
};

@Injectable({
providedIn: 'root',
})
export class RoomDetailsFacade {
private readonly roomsApi = inject(RoomsApi);
private readonly furnitureApi = inject(FurnitureApi);
private readonly stateSubject = new BehaviorSubject<RoomDetailsState>(EMPTY_STATE);

readonly state$ = this.stateSubject.asObservable();

get snapshotCells(): RoomCellDto[] {
return this.stateSubject.getValue().cells;
}

async load(roomId: UUID): Promise<void> {
const trimmedId = roomId.trim();
if (trimmedId.length === 0) {
const error = ApiError.validation({ roomId: 'Room id is required' });
this.patchState({ error, notFound: true });
throw error;
}

    this.patchState({ isLoading: true, error: null, notFound: false });

    try {
      const [room, cells, furniture] = await Promise.all([
        this.roomsApi.getRoom(trimmedId),
        this.roomsApi.getRoomCells(trimmedId),
        this.furnitureApi.listFurniture({ roomId: trimmedId }),
      ]);

      const placements = await this.loadPlacements(furniture);

      this.patchState({
        room,
        cells: cells.cells,
        furniture: furniture.map(mapFurnitureToListItem),
        placements,
        isLoading: false,
      });
    } catch (err: unknown) {
      const error = toApiError(err);
      if (error instanceof ApiError && error.status === 404) {
        this.patchState({
          isLoading: false,
          notFound: true,
          room: null,
          cells: [],
          furniture: [],
          placements: [],
          error: null,
        });
        return;
      }
      this.patchState({ isLoading: false, error });
      throw error;
    }
}

async createFurniture(
roomId: UUID,
payload: CreateFurniturePayload,
placement?: FurniturePlacementUpsertRequest
): Promise<void> {
if (roomId.trim().length === 0) {
const error = ApiError.validation({ roomId: 'Room id is required' });
this.patchState({ error });
throw error;
}

    const created = await this.furnitureApi.createFurniture({
      room_id: roomId,
      ...payload,
    });

    let nextPlacement: FurniturePlacementVM | null = null;
    if (placement) {
      const stored = await this.furnitureApi.upsertFurniturePlacement(created.id, placement);
      nextPlacement = this.toPlacementVm(stored, created.color, created.name);
    }

    const current = this.stateSubject.getValue();
    this.patchState({
      furniture: [mapFurnitureToListItem(created), ...current.furniture],
      placements: nextPlacement ? [nextPlacement, ...current.placements] : current.placements,
    });
}

async updateFurniture(
furnitureId: UUID,
payload: UpdateFurniturePayload,
placement?: FurniturePlacementUpsertRequest
): Promise<void> {
const updated = await this.furnitureApi.updateFurniture(furnitureId, payload);

    const current = this.stateSubject.getValue();
    const nextFurniture = current.furniture.map((item) =>
      item.id === furnitureId ? mapFurnitureToListItem(updated) : item
    );
    let nextPlacements = current.placements.map((item) =>
      item.furniture_id === furnitureId
        ? { ...item, color: updated.color, name: updated.name }
        : item
    );

    if (placement) {
      const stored = await this.furnitureApi.upsertFurniturePlacement(furnitureId, placement);
      const mapped = this.toPlacementVm(stored, updated.color, updated.name);
      const exists = nextPlacements.some((item) => item.furniture_id === furnitureId);
      nextPlacements = exists
        ? nextPlacements.map((item) => (item.furniture_id === furnitureId ? mapped : item))
        : [mapped, ...nextPlacements];
    }

    this.patchState({ furniture: nextFurniture, placements: nextPlacements });
}

async deleteFurniture(furnitureId: UUID): Promise<void> {
const current = this.stateSubject.getValue();
const previous = current.furniture;

    this.patchState({
      furniture: previous.filter((item) => item.id !== furnitureId),
      placements: current.placements.filter((placement) => placement.furniture_id !== furnitureId),
      error: null,
    });

    try {
      await this.furnitureApi.deleteFurniture(furnitureId);
    } catch (err: unknown) {
      const error = toApiError(err);
      this.patchState({ furniture: previous, placements: current.placements, error });
      throw error;
    }
}

private patchState(update: Partial<RoomDetailsState>): void {
const current = this.stateSubject.getValue();
this.stateSubject.next({ ...current, ...update });
}

private async loadPlacements(furniture: FurniturePlacementSource[]): Promise<FurniturePlacementVM[]> {
const results = await Promise.allSettled(
furniture.map(async (item) => {
try {
const placement = await this.furnitureApi.getFurniturePlacement(item.id);
return this.toPlacementVm(placement, item.color, item.name);
} catch {
return null;
}
})
);

    return results
      .map((result) => (result.status === 'fulfilled' ? result.value : null))
      .filter((placement): placement is FurniturePlacementVM => placement !== null);
}

private toPlacementVm(
placement: FurniturePlacementDto,
color: string,
name: string
): FurniturePlacementVM {
return {
furniture_id: placement.furniture_id,
room_id: placement.room_id,
x: placement.x,
y: placement.y,
width_cells: placement.width_cells,
height_cells: placement.height_cells,
color,
name,
};
}
}

export type CreateFurniturePayload = {
name: string;
description: string;
color: string;
};

export type UpdateFurniturePayload = CreateFurniturePayload;

type FurniturePlacementSource = { id: string; name: string; color: string };

export type FurniturePlacementVM = {
furniture_id: string;
room_id: string;
x: number;
y: number;
width_cells: number;
height_cells: number;
color: string;
name: string;
};

function toApiError(error: unknown): ApiError {
if (error instanceof ApiError) {
return error;
}

if (error instanceof Error) {
return new ApiError({
status: 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}

return new ApiError({
status: 500,
code: 'SUPABASE_ERROR',
message: 'Unknown error',
});
}



================================================
FILE: frontend/src/app/rooms/room-editor.facade.ts
================================================
import { Injectable, inject } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { ApiError } from '../shared/api-error';
import { RoomsApi } from './rooms.api';
import type {
CreateRoomCommand,
CreateRoomResponseDto,
RoomCellDto,
RoomDto,
UpdateRoomCommand,
UpdateRoomResponseDto,
} from './rooms.types';

export type RoomEditorState = {
room: RoomDto | null;
cells: RoomCellDto[];
isLoading: boolean;
isSaving: boolean;
error: ApiError | null;
notFound: boolean;
};

const EMPTY_STATE: RoomEditorState = {
room: null,
cells: [],
isLoading: false,
isSaving: false,
error: null,
notFound: false,
};

@Injectable({
providedIn: 'root',
})
export class RoomEditorFacade {
private readonly roomsApi = inject(RoomsApi);
private readonly stateSubject = new BehaviorSubject<RoomEditorState>(EMPTY_STATE);

readonly state$ = this.stateSubject.asObservable();

reset(): void {
this.stateSubject.next(EMPTY_STATE);
}

async load(roomId: string): Promise<void> {
const trimmedId = roomId.trim();
if (trimmedId.length === 0) {
const error = ApiError.validation({ roomId: 'Room id is required' });
this.patchState({ error, notFound: true });
throw error;
}

    this.patchState({ isLoading: true, error: null, notFound: false });

    try {
      const [room, cells] = await Promise.all([
        this.roomsApi.getRoom(trimmedId),
        this.roomsApi.getRoomCells(trimmedId),
      ]);
      this.patchState({ room, cells: cells.cells, isLoading: false });
    } catch (err: unknown) {
      const error = toApiError(err);
      if (error instanceof ApiError && error.status === 404) {
        this.patchState({
          isLoading: false,
          notFound: true,
          room: null,
          cells: [],
          error: null,
        });
        return;
      }
      this.patchState({ isLoading: false, error });
      throw error;
    }
}

async createRoom(command: CreateRoomCommand): Promise<CreateRoomResponseDto> {
this.patchState({ isSaving: true, error: null });
try {
const room = await this.roomsApi.createRoom(command);
this.patchState({ isSaving: false });
return room;
} catch (err: unknown) {
const error = toApiError(err);
this.patchState({ isSaving: false, error });
throw error;
}
}

async updateRoom(roomId: string, command: UpdateRoomCommand): Promise<UpdateRoomResponseDto> {
this.patchState({ isSaving: true, error: null });
try {
const room = await this.roomsApi.updateRoom(roomId, command);
const current = this.stateSubject.getValue();
const nextRoom = current.room ? { ...current.room, ...room } : current.room;
this.patchState({ isSaving: false, room: nextRoom });
return room;
} catch (err: unknown) {
const error = toApiError(err);
this.patchState({ isSaving: false, error });
throw error;
}
}

async replaceRoomCells(roomId: string, cells: RoomCellDto[]): Promise<void> {
this.patchState({ isSaving: true, error: null });
try {
await this.roomsApi.replaceRoomCells(roomId, { cells });
this.patchState({ isSaving: false, cells });
} catch (err: unknown) {
const error = toApiError(err);
this.patchState({ isSaving: false, error });
throw error;
}
}

private patchState(update: Partial<RoomEditorState>): void {
const current = this.stateSubject.getValue();
this.stateSubject.next({ ...current, ...update });
}
}

function toApiError(error: unknown): ApiError {
if (error instanceof ApiError) {
return error;
}

if (error instanceof Error) {
return new ApiError({
status: 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}

return new ApiError({
status: 500,
code: 'SUPABASE_ERROR',
message: 'Unknown error',
});
}



================================================
FILE: frontend/src/app/rooms/room-grid-editor.service.ts
================================================
import { Injectable } from '@angular/core';

export type RoomGridCell = {
x: number;
y: number;
filled: boolean;
allowed: boolean;
};

export type RoomGridState = {
width: number;
height: number;
cellSizeM: number;
cells: RoomGridCell[];
filled: Set<string>;
allowed?: Set<string>;
};

export type GridBounds = {
xStart: number;
yStart: number;
widthCells: number;
heightCells: number;
};

@Injectable({
providedIn: 'root',
})
export class RoomGridEditorService {
private readonly cellSizeM = 0.5;

createGrid(width = 40, height = 40, fillAll = false): RoomGridState {
const safeWidth = Math.max(1, Math.min(width, 40));
const safeHeight = Math.max(1, Math.min(height, 40));

    const filled = new Set<string>();
    const cells: RoomGridCell[] = [];

    for (let y = 0; y < safeHeight; y += 1) {
      for (let x = 0; x < safeWidth; x += 1) {
        const isFilled = fillAll;
        if (isFilled) {
          filled.add(this.key(x, y));
        }
        cells.push({ x, y, filled: isFilled, allowed: true });
      }
    }

    return {
      width: safeWidth,
      height: safeHeight,
      cellSizeM: this.cellSizeM,
      cells,
      filled,
    };
}

fillRectangle(state: RoomGridState, bounds: GridBounds): RoomGridState {
for (let y = bounds.yStart; y < bounds.yStart + bounds.heightCells; y += 1) {
for (let x = bounds.xStart; x < bounds.xStart + bounds.widthCells; x += 1) {
const cell = state.cells.find((item) => item.x === x && item.y === y);
if (!cell) {
continue;
}
this.setCell(state, cell, true);
}
}

    return state;
}

applyCells(state: RoomGridState, cells: Array<{ x: number; y: number }>): RoomGridState {
state.filled.clear();
state.cells.forEach((cell) => {
cell.filled = false;
});

    cells.forEach((coord) => {
      const cell = state.cells.find((item) => item.x === coord.x && item.y === coord.y);
      if (!cell) {
        return;
      }
      this.setCell(state, cell, true);
    });

    return state;
}

getFilledCells(state: RoomGridState): Array<{ x: number; y: number }> {
return Array.from(state.filled.values()).map((value) => {
const [x, y] = value.split(':').map((part) => Number.parseInt(part, 10));
return { x, y };
});
}

setCell(state: RoomGridState, cell: RoomGridCell, filled: boolean): RoomGridState {
const key = this.key(cell.x, cell.y);
if (filled) {
if (state.allowed && !state.allowed.has(key)) {
return state;
}
if (!this.canFillCell(state, cell)) {
return state;
}
state.filled.add(key);
cell.filled = true;
return state;
}

    state.filled.delete(key);
    cell.filled = false;
    return state;
}

toggleCell(state: RoomGridState, cell: RoomGridCell): RoomGridState {
if (!state.filled.has(this.key(cell.x, cell.y))) {
if (!this.canFillCell(state, cell)) {
return state;
}

      return this.setCell(state, cell, true);
    }

    return this.setCell(state, cell, false);
}

getBounds(state: RoomGridState): GridBounds | null {
if (state.filled.size === 0) {
return null;
}

    const coords = Array.from(state.filled.values()).map((value) => {
      const [x, y] = value.split(':').map((part) => Number.parseInt(part, 10));
      return { x, y };
    });

    const xs = coords.map((coord) => coord.x);
    const ys = coords.map((coord) => coord.y);

    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);

    return {
      xStart: minX,
      yStart: minY,
      widthCells: maxX - minX + 1,
      heightCells: maxY - minY + 1,
    };
}

canFillCell(state: RoomGridState, cell: RoomGridCell): boolean {
if (state.allowed && !state.allowed.has(this.key(cell.x, cell.y))) {
return false;
}

    if (state.filled.size === 0) {
      return true;
    }

    return this.hasNeighbor(state, cell.x, cell.y);
}

private hasNeighbor(state: RoomGridState, x: number, y: number): boolean {
const neighbors = [
this.key(x - 1, y),
this.key(x + 1, y),
this.key(x, y - 1),
this.key(x, y + 1),
];

    return neighbors.some((key) => state.filled.has(key));
}

private key(x: number, y: number): string {
return `${x}:${y}`;
}

applyAllowedCells(state: RoomGridState, cells: Array<{ x: number; y: number }>): RoomGridState {
const allowed = new Set(cells.map((cell) => this.key(cell.x, cell.y)));
state.allowed = allowed;

    for (const key of Array.from(state.filled)) {
      if (!allowed.has(key)) {
        state.filled.delete(key);
      }
    }

    state.cells.forEach((cell) => {
      const key = this.key(cell.x, cell.y);
      cell.allowed = allowed.has(key);
      if (!cell.allowed) {
        cell.filled = false;
      }
    });

    return state;
}
}



================================================
FILE: frontend/src/app/rooms/rooms-list.facade.ts
================================================
import { Injectable, inject } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { ApiError } from '../shared/api-error';
import type { UUID } from './rooms.types';
import { RoomsApi } from './rooms.api';
import {
EMPTY_ROOMS_LIST_STATE,
mapRoomToListItem,
type RoomsListState,
} from './rooms.view-models';

@Injectable({
providedIn: 'root',
})
export class RoomsListFacade {
private readonly roomsApi = inject(RoomsApi);
private readonly stateSubject = new BehaviorSubject<RoomsListState>(EMPTY_ROOMS_LIST_STATE);

readonly state$ = this.stateSubject.asObservable();

async loadRooms(): Promise<void> {
const current = this.stateSubject.getValue();
if (current.isLoading) {
return;
}

    this.patchState({ isLoading: true, error: null });

    try {
      const response = await this.roomsApi.listRooms({ sort: 'created_at', order: 'desc' });
      const roomsVm = response.data.map(mapRoomToListItem);
      this.patchState({ rooms: roomsVm, isLoading: false });
    } catch (err: unknown) {
      const error = toApiError(err);
      this.patchState({ isLoading: false, error });
      throw error;
    }
}

async deleteRoom(roomId: UUID): Promise<void> {
if (roomId.trim().length === 0) {
const error = ApiError.validation({ roomId: 'Room id is required' });
this.patchState({ error });
throw error;
}

    const current = this.stateSubject.getValue();
    const previousRooms = current.rooms;
    this.patchState({ rooms: previousRooms.filter((room) => room.id !== roomId), error: null });

    try {
      await this.roomsApi.deleteRoom(roomId);
    } catch (err: unknown) {
      const error = toApiError(err);
      this.patchState({ rooms: previousRooms, error });
      throw error;
    }
}

private patchState(update: Partial<RoomsListState>): void {
const current = this.stateSubject.getValue();
this.stateSubject.next({ ...current, ...update });
}
}

function toApiError(error: unknown): ApiError {
if (error instanceof ApiError) {
return error;
}

if (error instanceof Error) {
return new ApiError({
status: 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}

return new ApiError({
status: 500,
code: 'SUPABASE_ERROR',
message: 'Unknown error',
});
}



================================================
FILE: frontend/src/app/rooms/rooms.api.ts
================================================
import { Injectable, inject } from '@angular/core';
import { SupabaseService } from '../../db/supabase.service';
import type {
CreateRoomCommand,
CreateRoomPayload,
ListRoomsQuery,
CreateRoomResponseDto,
RoomDto,
RoomCellsGetResponseDto,
RoomCellsPutRequestDto,
RoomCellsPutResponseDto,
RoomsListResponseDto,
UpdateRoomResponseDto,
UpdateRoomCommand,
UUID,
} from './rooms.types';
import {
ROOM_CELLS_SELECT,
ROOM_CREATE_SELECT,
ROOM_DTO_SELECT,
ROOM_LIST_SELECT,
ROOM_UPDATE_SELECT,
} from './rooms.types';
import { ApiError } from '../shared/api-error';
import {
mapCreateRoomPostgrestError,
mapDeleteRoomPostgrestError,
mapGetRoomPostgrestError,
mapListRoomsPostgrestError,
mapRoomCellsPostgrestError,
mapUpdateRoomPostgrestError,
} from './rooms.errors';
import {
validateCreateRoomCommand,
validateListRoomsQuery,
validateRoomCellsRequest,
validateRoomId,
validateUpdateRoomCommand,
} from './rooms.validation';
import { AuthSessionService } from '../auth/auth-session.service';

@Injectable({
providedIn: 'root',
})
export class RoomsApi {
private readonly supabase = inject(SupabaseService);
private readonly authSession = inject(AuthSessionService);

async getRoom(roomId: UUID): Promise<RoomDto> {
const idErrors = validateRoomId(roomId);
if (idErrors) {
throw ApiError.validation(idErrors);
}

    const { data, error, status } = await this.supabase
      .getClient()
      .from('rooms')
      .select(ROOM_DTO_SELECT)
      .eq('id', roomId)
      .maybeSingle();

    if (error) {
      throw mapGetRoomPostgrestError(error, status);
    }

    if (!data) {
      throw ApiError.notFound('Room not found');
    }

    return data;
}

async listRooms(query: ListRoomsQuery = {}): Promise<RoomsListResponseDto> {
const validationErrors = validateListRoomsQuery(query);
if (validationErrors) {
throw ApiError.validation(validationErrors);
}

    const client = this.supabase.getClient();
    const orderBy = query.sort ?? query.orderBy ?? 'created_at';
    const orderDirection = query.order ?? query.orderDirection ?? 'desc';

    let request = client
      .from('rooms')
      .select(ROOM_LIST_SELECT, { count: 'exact' })
      .order(orderBy, {
        ascending: orderDirection === 'asc',
      });

    if (query.name) {
      request = request.ilike('name', `%${query.name.trim()}%`);
    }

    if (query.limit !== undefined) {
      const start = query.offset ?? 0;
      const end = start + query.limit - 1;
      request = request.range(start, end);
    }

    const { data, error, status, count } = await request;

    if (error) {
      throw mapListRoomsPostgrestError(error, status);
    }

    const safeData = data ?? [];
    const limit = query.limit ?? safeData.length;
    const offset = query.offset ?? 0;

    return {
      data: safeData,
      meta: {
        limit,
        offset,
        total: count ?? safeData.length,
      },
    };
}

async createRoom(command: CreateRoomCommand): Promise<CreateRoomResponseDto> {
const validationErrors = validateCreateRoomCommand(command);
if (validationErrors) {
throw ApiError.validation(validationErrors);
}

    const client = this.supabase.getClient();
    const userId = this.authSession.getUserIdOrThrow();

    const payload: CreateRoomPayload = {
      user_id: userId,
      created_by: userId,
      ...command,
    };

    const { data, error, status } = await client
      .from('rooms')
      .insert(payload)
      .select(ROOM_CREATE_SELECT)
      .single();

    if (error) {
      throw mapCreateRoomPostgrestError(error, status);
    }

    return data;
}

async updateRoom(roomId: UUID, command: UpdateRoomCommand): Promise<UpdateRoomResponseDto> {
const idErrors = validateRoomId(roomId);
if (idErrors) {
throw ApiError.validation(idErrors);
}

    const validationErrors = validateUpdateRoomCommand(command);
    if (validationErrors) {
      throw ApiError.validation(validationErrors);
    }

    const { data, error, status } = await this.supabase
      .getClient()
      .from('rooms')
      .update(command)
      .eq('id', roomId)
      .select(ROOM_UPDATE_SELECT)
      .maybeSingle();

    if (error) {
      throw mapUpdateRoomPostgrestError(error, status);
    }

    if (!data) {
      throw ApiError.notFound('Room not found');
    }

    return data;
}

async deleteRoom(roomId: UUID): Promise<void> {
const idErrors = validateRoomId(roomId);
if (idErrors) {
throw ApiError.validation(idErrors);
}

    const { data, error, status } = await this.supabase
      .getClient()
      .from('rooms')
      .delete()
      .eq('id', roomId)
      .select('id')
      .maybeSingle();

    if (error) {
      throw mapDeleteRoomPostgrestError(error, status);
    }

    if (!data) {
      throw ApiError.notFound('Room not found');
    }
}

async getRoomCells(roomId: UUID): Promise<RoomCellsGetResponseDto> {
const idErrors = validateRoomId(roomId);
if (idErrors) {
throw ApiError.validation(idErrors);
}

    const { data, error, status } = await this.supabase
      .getClient()
      .from('room_cells')
      .select(ROOM_CELLS_SELECT)
      .eq('room_id', roomId)
      .order('y', { ascending: true })
      .order('x', { ascending: true });

    if (error) {
      throw mapRoomCellsPostgrestError(error, status);
    }

    return {
      room_id: roomId,
      cells: data ?? [],
    };
}

async replaceRoomCells(
roomId: UUID,
request: RoomCellsPutRequestDto
): Promise<RoomCellsPutResponseDto> {
const idErrors = validateRoomId(roomId);
if (idErrors) {
throw ApiError.validation(idErrors);
}

    const validationErrors = validateRoomCellsRequest(request);
    if (validationErrors) {
      throw ApiError.validation(validationErrors);
    }

    const client = this.supabase.getClient();

    const { error: deleteError, status: deleteStatus } = await client
      .from('room_cells')
      .delete()
      .eq('room_id', roomId);

    if (deleteError) {
      throw mapRoomCellsPostgrestError(deleteError, deleteStatus);
    }

    const payload = request.cells.map((cell) => ({
      room_id: roomId,
      x: cell.x,
      y: cell.y,
    }));

    if (payload.length === 0) {
      return { room_id: roomId, cells_saved: 0 };
    }

    const { error: insertError, status: insertStatus } = await client
      .from('room_cells')
      .insert(payload);

    if (insertError) {
      throw mapRoomCellsPostgrestError(insertError, insertStatus);
    }

    return {
      room_id: roomId,
      cells_saved: payload.length,
    };
}
}



================================================
FILE: frontend/src/app/rooms/rooms.errors.ts
================================================
import type { PostgrestError } from '@supabase/postgrest-js';
import { ApiError } from '../shared/api-error';

const NOT_FOUND_STATUS = 404;
const NO_ROWS_STATUS = 406;
const NO_ROWS_CODE = 'PGRST116';

function isNotFoundError(error: PostgrestError, status?: number): boolean {
return status === NOT_FOUND_STATUS || status === NO_ROWS_STATUS || error.code === NO_ROWS_CODE;
}

export function mapCreateRoomPostgrestError(error: PostgrestError, status?: number): ApiError {
if (status === 401) {
return ApiError.unauthorized(error.message);
}

if (error.code === '23505') {
return ApiError.conflict('Room name already exists', undefined, error);
}

if (error.code === '23514' || error.code === '23502') {
return ApiError.constraint(error.message, undefined, error);
}

if (error.code === '22P02') {
return ApiError.badRequest(error.message, undefined, error);
}

return new ApiError({
status: status ?? 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}

export function mapListRoomsPostgrestError(error: PostgrestError, status?: number): ApiError {
if (status === 401) {
return ApiError.unauthorized(error.message);
}

if (status === 400 || error.code === '22P02') {
return ApiError.badRequest(error.message, undefined, error);
}

return new ApiError({
status: status ?? 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}

export function mapGetRoomPostgrestError(error: PostgrestError, status?: number): ApiError {
if (status === 401) {
return ApiError.unauthorized(error.message);
}

if (isNotFoundError(error, status)) {
return ApiError.notFound('Room not found');
}

if (status === 400 || error.code === '22P02') {
return ApiError.badRequest(error.message, undefined, error);
}

return new ApiError({
status: status ?? 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}

export function mapUpdateRoomPostgrestError(error: PostgrestError, status?: number): ApiError {
if (status === 401) {
return ApiError.unauthorized(error.message);
}

if (isNotFoundError(error, status)) {
return ApiError.notFound('Room not found');
}

if (error.code === '23505') {
return ApiError.conflict('Room name already exists', undefined, error);
}

if (error.code === '23514' || error.code === '23502') {
return ApiError.constraint(error.message, undefined, error);
}

if (error.code === '22P02') {
return ApiError.badRequest(error.message, undefined, error);
}

return new ApiError({
status: status ?? 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}

export function mapDeleteRoomPostgrestError(error: PostgrestError, status?: number): ApiError {
if (status === 401) {
return ApiError.unauthorized(error.message);
}

if (isNotFoundError(error, status)) {
return ApiError.notFound('Room not found');
}

if (status === 400 || error.code === '22P02') {
return ApiError.badRequest(error.message, undefined, error);
}

return new ApiError({
status: status ?? 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}

export function mapRoomCellsPostgrestError(error: PostgrestError, status?: number): ApiError {
if (status === 401) {
return ApiError.unauthorized(error.message);
}

if (status === 400 || error.code === '22P02') {
return ApiError.badRequest(error.message, undefined, error);
}

return new ApiError({
status: status ?? 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}



================================================
FILE: frontend/src/app/rooms/rooms.types.ts
================================================
import type { Tables, TablesInsert, TablesUpdate } from '../../db/database.types';

export type UUID = string;

export type RoomRow = Tables<'rooms'>;
export type RoomInsert = TablesInsert<'rooms'>;
export type RoomUpdate = TablesUpdate<'rooms'>;
export type RoomCellRow = Tables<'room_cells'>;

export type OffsetPaginationMeta = {
limit: number;
offset: number;
};

export type OffsetPaginationWithTotalMeta = OffsetPaginationMeta & {
total: number;
};

export type RoomListItemDto = Pick<RoomRow, 'id' | 'name' | 'color'>;

export type RoomDto = Pick<
RoomRow,
'id' | 'name' | 'color' | 'created_at' | 'updated_at'
>;

export type RoomOrderBy = 'created_at' | 'name';
export type RoomOrderDirection = 'asc' | 'desc';

export type ListRoomsQuery = {
name?: string;
limit?: number;
offset?: number;
sort?: RoomOrderBy;
order?: RoomOrderDirection;
orderBy?: RoomOrderBy;
orderDirection?: RoomOrderDirection;
};

export type RoomsListResponseDto = {
data: RoomListItemDto[];
meta: OffsetPaginationWithTotalMeta;
};

export type CreateRoomCommand = Pick<RoomRow, 'name' | 'color'>;

export type CreateRoomPayload = CreateRoomCommand & Pick<RoomInsert, 'user_id' | 'created_by'>;

export type CreateRoomResponseDto = Pick<RoomRow, 'id' | 'name' | 'color' | 'created_at'>;

export type UpdateRoomCommand = Partial<Pick<RoomRow, 'name' | 'color'>>;

export type UpdateRoomPayload = UpdateRoomCommand & RoomUpdate;

export type UpdateRoomResponseDto = Pick<RoomRow, 'id' | 'name' | 'color' | 'updated_at'>;

export const ROOM_DTO_SELECT = 'id,name,color,created_at,updated_at' as const;

export const ROOM_LIST_SELECT = 'id,name,color' as const;
export const ROOM_CREATE_SELECT = 'id,name,color,created_at' as const;
export const ROOM_UPDATE_SELECT = 'id,name,color,updated_at' as const;

export type RoomCellDto = Pick<RoomCellRow, 'x' | 'y'>;

export type RoomCellsGetResponseDto = {
room_id: RoomRow['id'];
cells: RoomCellDto[];
};

export type RoomCellsPutRequestDto = {
cells: RoomCellDto[];
};

export type RoomCellsPutResponseDto = {
room_id: RoomRow['id'];
cells_saved: number;
};

export const ROOM_CELLS_SELECT = 'x,y' as const;



================================================
FILE: frontend/src/app/rooms/rooms.validation.ts
================================================
import type {
CreateRoomCommand,
ListRoomsQuery,
RoomCellDto,
RoomCellsPutRequestDto,
UpdateRoomCommand,
} from './rooms.types';

const HEX_COLOR_RE = /^#[0-9a-fA-F]{6}$/;

type CreateRoomField = keyof CreateRoomCommand;
type ListRoomsField = keyof ListRoomsQuery;
type UpdateRoomField = keyof UpdateRoomCommand;

function isInteger(value: unknown): value is number {
return typeof value === 'number' && Number.isInteger(value);
}

export function validateCreateRoomCommand(command: CreateRoomCommand): Record<string, string> | null {
const errors: Partial<Record<CreateRoomField, string>> = {};

const trimmedName = command.name.trim();
if (trimmedName.length === 0) {
errors.name = 'Name is required';
} else if (trimmedName.length > 120) {
errors.name = 'Name must be at most 120 characters';
}

if (!HEX_COLOR_RE.test(command.color)) {
errors.color = 'Color must be a hex value like #aabbcc';
}

if (Object.keys(errors).length === 0) {
return null;
}

return errors as Record<string, string>;
}

export function validateListRoomsQuery(query: ListRoomsQuery): Record<string, string> | null {
const errors: Partial<Record<ListRoomsField, string>> = {};

if (typeof query.name === 'string') {
const trimmedName = query.name.trim();
if (trimmedName.length === 0) {
errors.name = 'Name filter cannot be empty';
} else if (trimmedName.length > 120) {
errors.name = 'Name filter must be at most 120 characters';
}
}

if (query.limit !== undefined) {
if (!isInteger(query.limit) || query.limit < 1 || query.limit > 200) {
errors.limit = 'limit must be an integer between 1 and 200';
}
}

if (query.offset !== undefined) {
if (!isInteger(query.offset) || query.offset < 0) {
errors.offset = 'offset must be an integer >= 0';
} else if (query.limit === undefined) {
errors.offset = 'offset requires limit to be set';
}
}

if (query.orderBy !== undefined && query.orderBy !== 'created_at' && query.orderBy !== 'name') {
errors.orderBy = 'orderBy must be one of: created_at, name';
}

if (query.sort !== undefined && query.sort !== 'created_at' && query.sort !== 'name') {
errors.sort = 'sort must be one of: created_at, name';
}

if (
query.orderDirection !== undefined &&
query.orderDirection !== 'asc' &&
query.orderDirection !== 'desc'
) {
errors.orderDirection = 'orderDirection must be one of: asc, desc';
}

if (query.order !== undefined && query.order !== 'asc' && query.order !== 'desc') {
errors.order = 'order must be one of: asc, desc';
}

if (Object.keys(errors).length === 0) {
return null;
}

return errors as Record<string, string>;
}

export function validateUpdateRoomCommand(command: UpdateRoomCommand): Record<string, string> | null {
const errors: Partial<Record<UpdateRoomField, string>> = {};

if (command.name !== undefined) {
const trimmedName = command.name.trim();
if (trimmedName.length === 0) {
errors.name = 'Name is required';
} else if (trimmedName.length > 120) {
errors.name = 'Name must be at most 120 characters';
}
}

if (command.color !== undefined && !HEX_COLOR_RE.test(command.color)) {
errors.color = 'Color must be a hex value like #aabbcc';
}

if (command.name === undefined && command.color === undefined) {
errors.name = 'At least one field must be provided';
}

if (Object.keys(errors).length === 0) {
return null;
}

return errors as Record<string, string>;
}

export function validateRoomId(roomId: string): Record<string, string> | null {
if (roomId.trim().length === 0) {
return { roomId: 'Room id is required' };
}

return null;
}

export function validateRoomCellsRequest(
request: RoomCellsPutRequestDto
): Record<string, string> | null {
const errors: Record<string, string> = {};
const cells = request.cells;

if (!Array.isArray(cells) || cells.length === 0) {
errors['cells'] = 'At least one cell is required';
return errors;
}

cells.forEach((cell: RoomCellDto, index: number) => {
if (!isInteger(cell.x) || cell.x < 0 || cell.x > 49) {
errors[`cells.${index}.x`] = 'x must be an integer between 0 and 49';
}
if (!isInteger(cell.y) || cell.y < 0 || cell.y > 49) {
errors[`cells.${index}.y`] = 'y must be an integer between 0 and 49';
}
});

return Object.keys(errors).length === 0 ? null : errors;
}



================================================
FILE: frontend/src/app/rooms/rooms.view-models.ts
================================================
import type { ApiError } from '../shared/api-error';
import type { RoomListItemDto, UUID } from './rooms.types';

export type RoomListItemVM = {
id: UUID;
name: string;
color: string;
};

export type RoomsListState = {
rooms: RoomListItemVM[];
isLoading: boolean;
error: ApiError | null;
};

export const EMPTY_ROOMS_LIST_STATE: RoomsListState = {
rooms: [],
isLoading: false,
error: null,
};

export function mapRoomToListItem(room: RoomListItemDto): RoomListItemVM {
return {
id: room.id,
name: room.name,
color: room.color,
};
}



================================================
FILE: frontend/src/app/rooms/components/room-card.component.ts
================================================
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import type { RoomListItemVM } from '../rooms.view-models';

@Component({
selector: 'app-room-card',
standalone: true,
imports: [MatCardModule, MatButtonModule],
template: `
    <mat-card class="room-card" (click)="open.emit(room.id)">
      <div class="room-card__color" [style.backgroundColor]="room.color" aria-hidden="true"></div>
      <div class="room-card__content">
        <div class="room-card__title">
          <h3>{{ room.name }}</h3>
        </div>
        <div class="room-card__actions">
          <button
            mat-stroked-button
            color="primary"
            type="button"
            (click)="handleEdit($event)"
            aria-label="Edytuj pokoj"
          >
            Edytuj
          </button>
          <button
            mat-stroked-button
            color="warn"
            type="button"
            (click)="handleDelete($event)"
            aria-label="Usun pokoj"
          >
            Usun
          </button>
        </div>
      </div>
    </mat-card>
  `,
styles: [
`
.room-card {
display: grid;
grid-template-columns: 12px 1fr;
gap: 16px;
cursor: pointer;
padding: 6px 8px 6px 0;
}

      .room-card__color {
        width: 12px;
        border-radius: 8px;
      }

      .room-card__content {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        flex-wrap: nowrap;
      }

      .room-card__title {
        display: flex;
        align-items: baseline;
        gap: 12px;
        white-space: nowrap;
      }

      .room-card__title h3 {
        margin: 0;
        font-size: 1.1rem;
      }

      .room-card__actions {
        display: flex;
        gap: 8px;
        flex-shrink: 0;
      }
    `,
],
})
export class RoomCardComponent {
@Input({ required: true }) room!: RoomListItemVM;
@Output() open = new EventEmitter<string>();
@Output() edit = new EventEmitter<string>();
@Output() delete = new EventEmitter<string>();

handleEdit(event: MouseEvent): void {
event.stopPropagation();
this.edit.emit(this.room.id);
}

handleDelete(event: MouseEvent): void {
event.stopPropagation();
this.delete.emit(this.room.id);
}
}



================================================
FILE: frontend/src/app/rooms/components/room-color-picker.component.ts
================================================
import { NgFor } from '@angular/common';
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';

export type ColorOption = {
value: string;
label?: string;
};

@Component({
selector: 'app-room-color-picker',
standalone: true,
imports: [MatButtonModule, NgFor],
template: `
    <div class="color-picker">
      <button
        *ngFor="let color of colors; trackBy: trackByColor"
        mat-icon-button
        type="button"
        class="color-picker__swatch"
        [class.color-picker__swatch--active]="color.value === value"
        [style.backgroundColor]="color.value"
        (click)="selectColor(color.value)"
        [attr.aria-label]="color.label ?? color.value"
      ></button>
    </div>
  `,
styles: [
`
.color-picker {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(32px, 1fr));
gap: 8px;
}

      .color-picker__swatch {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        border: 2px solid transparent;
      }

      .color-picker__swatch--active {
        border-color: rgba(0, 0, 0, 0.6);
      }
    `,
],
})
export class RoomColorPickerComponent {
@Input() colors: ColorOption[] = [];
@Input() value = '';
@Output() valueChange = new EventEmitter<string>();

selectColor(color: string): void {
this.valueChange.emit(color);
}

trackByColor(index: number, color: ColorOption): string {
return color.value;
}
}



================================================
FILE: frontend/src/app/rooms/components/room-editor-actions.component.ts
================================================
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';

@Component({
selector: 'app-room-editor-actions',
standalone: true,
imports: [MatButtonModule],
template: `
    <div class="room-editor-actions">
      <button mat-stroked-button type="button" (click)="cancel.emit()">Anuluj</button>
      <button
        mat-flat-button
        color="primary"
        type="button"
        [disabled]="!canSave || isSaving"
        (click)="save.emit()"
      >
        {{ isSaving ? 'Zapisywanie...' : 'Zapisz' }}
      </button>
    </div>
  `,
styles: [
`
      .room-editor-actions {
        display: flex;
        justify-content: flex-end;
        gap: 12px;
      }
    `,
],
})
export class RoomEditorActionsComponent {
@Input() canSave = false;
@Input() isSaving = false;
@Output() save = new EventEmitter<void>();
@Output() cancel = new EventEmitter<void>();
}



================================================
FILE: frontend/src/app/rooms/components/room-form.component.ts
================================================
import { NgIf } from '@angular/common';
import { Component, EventEmitter, Input, OnDestroy, OnInit, Output } from '@angular/core';
import { FormControl, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import type { Subscription } from 'rxjs';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { RoomColorPickerComponent, type ColorOption } from './room-color-picker.component';

export type RoomFormValue = {
name: string;
color: string;
};

@Component({
selector: 'app-room-form',
standalone: true,
imports: [ReactiveFormsModule, MatFormFieldModule, MatInputModule, RoomColorPickerComponent, NgIf],
template: `
<form [formGroup]="form" class="room-form">
<mat-form-field appearance="outline">
<mat-label>Nazwa pokoju</mat-label>
<input matInput formControlName="name" maxlength="100" />
<mat-error *ngIf="form.controls.name.hasError('required')">Nazwa jest wymagana.</mat-error>
<mat-error *ngIf="form.controls.name.hasError('maxlength')">
Maksymalnie 100 znakow.
</mat-error>
</mat-form-field>

      <div class="room-form__colors">
        <label>Kolor pokoju</label>
        <app-room-color-picker
          [colors]="palette"
          [value]="form.controls.color.value"
          (valueChange)="onColorSelect($event)"
        ></app-room-color-picker>
        <mat-form-field appearance="outline">
          <mat-label>HEX</mat-label>
          <input matInput formControlName="color" maxlength="7" />
          <mat-error *ngIf="form.controls.color.hasError('pattern')">
            Podaj poprawny kolor, np. #aabbcc.
          </mat-error>
          <mat-error *ngIf="form.controls.color.hasError('required')">
            Kolor jest wymagany.
          </mat-error>
        </mat-form-field>
      </div>
    </form>
`,
  styles: [
    `
.room-form {
display: grid;
gap: 16px;
}

      .room-form__colors {
        display: grid;
        gap: 12px;
      }
    `,
],
})
export class RoomFormComponent {
@Input() set value(value: RoomFormValue) {
this.form.setValue(value, { emitEvent: false });
}

@Output() valueChange = new EventEmitter<RoomFormValue>();

readonly form = new FormGroup({
name: new FormControl('', {
nonNullable: true,
validators: [Validators.required, Validators.maxLength(100)],
}),
color: new FormControl('#aabbcc', {
nonNullable: true,
validators: [Validators.required, Validators.pattern(/^#[0-9a-fA-F]{6}$/)],
}),
});

readonly palette: ColorOption[] = [
{ value: '#f44336' },
{ value: '#e91e63' },
{ value: '#9c27b0' },
{ value: '#673ab7' },
{ value: '#3f51b5' },
{ value: '#2196f3' },
{ value: '#03a9f4' },
{ value: '#00bcd4' },
{ value: '#009688' },
{ value: '#4caf50' },
{ value: '#8bc34a' },
{ value: '#cddc39' },
{ value: '#ffeb3b' },
{ value: '#ffc107' },
{ value: '#ff9800' },
{ value: '#ff5722' },
{ value: '#795548' },
{ value: '#9e9e9e' },
{ value: '#607d8b' },
{ value: '#263238' },
];

private subscription?: Subscription;

ngOnInit(): void {
this.subscription = this.form.valueChanges.subscribe(() => {
this.valueChange.emit(this.form.getRawValue());
});
}

onColorSelect(color: string): void {
this.form.controls.color.setValue(color);
}

ngOnDestroy(): void {
this.subscription?.unsubscribe();
}
}



================================================
FILE: frontend/src/app/rooms/components/room-grid-editor.component.ts
================================================
import { NgFor } from '@angular/common';
import { Component, EventEmitter, HostListener, Input, Output } from '@angular/core';
import type { RoomGridCell, RoomGridState } from '../room-grid-editor.service';

@Component({
selector: 'app-room-grid-editor',
standalone: true,
imports: [NgFor],
template: `
    <section class="grid-editor" aria-label="Edytor siatki pokoju">
      <div
        class="grid-editor__grid"
        [style.gridTemplateColumns]="gridTemplateColumns"
        [style.--cell-size.px]="cellSizePx"
        [style.--fill-color]="fillColor"
      >
        <button
          *ngFor="let cell of grid.cells; trackBy: trackByIndex"
          type="button"
          class="grid-editor__cell"
          [class.grid-editor__cell--filled]="cell.filled"
          [class.grid-editor__cell--disabled]="!cell.allowed"
          [disabled]="!cell.allowed"
          (click)="handleClick(cell)"
          (pointerdown)="handlePointerDown(cell, $event)"
          (pointerenter)="handlePointerEnter(cell)"
          [attr.aria-pressed]="cell.filled"
          [attr.aria-label]="cell.filled ? 'Zaznaczona komorka' : 'Pusta komorka'"
        ></button>
      </div>
    </section>
  `,
styles: [
`
.grid-editor__grid {
display: grid;
gap: 2px;
background: rgba(0, 0, 0, 0.08);
padding: 8px;
border-radius: 12px;
width: fit-content;
max-width: 100%;
overflow: auto;
}

      .grid-editor__cell {
        width: var(--cell-size);
        height: var(--cell-size);
        border: 1px solid rgba(0, 0, 0, 0.05);
        background: #fff;
        border-radius: 2px;
        cursor: pointer;
      }

      .grid-editor__cell--filled {
        background: var(--fill-color);
      }

      .grid-editor__cell--disabled {
        background: #f0f0f0;
        border-style: dashed;
        cursor: not-allowed;
      }
    `,
],
})
export class RoomGridEditorComponent {
@Input({ required: true }) grid!: RoomGridState;
@Input() cellSizePx = 16;
@Input() fillColor = '#212121';
@Input() brushSize = 1;
@Output() setCell = new EventEmitter<{ cell: RoomGridCell; filled: boolean }>();

private isDragging = false;
private dragFill = true;
private suppressClick = false;

get gridTemplateColumns(): string {
return `repeat(${this.grid.width}, var(--cell-size))`;
}

@HostListener('document:pointerup')
onPointerUp(): void {
this.isDragging = false;
}

handlePointerDown(cell: RoomGridCell, event: PointerEvent): void {
event.preventDefault();
this.suppressClick = true;
this.isDragging = true;
this.dragFill = !cell.filled;
this.applyBrush(cell, this.dragFill);
}

handlePointerEnter(cell: RoomGridCell): void {
if (!this.isDragging) {
return;
}

    this.applyBrush(cell, this.dragFill);
}

handleClick(cell: RoomGridCell): void {
if (this.suppressClick) {
this.suppressClick = false;
return;
}

    this.applyBrush(cell, !cell.filled);
}

trackByIndex(index: number): number {
return index;
}

private applyBrush(cell: RoomGridCell, filled: boolean): void {
const size = this.normalizeBrushSize(this.brushSize);
const radius = Math.floor(size / 2);

    for (let y = cell.y - radius; y <= cell.y + radius; y += 1) {
      for (let x = cell.x - radius; x <= cell.x + radius; x += 1) {
        const target = this.getCellAt(x, y);
        if (!target) {
          continue;
        }
        this.setCell.emit({ cell: target, filled });
      }
    }
}

private getCellAt(x: number, y: number): RoomGridCell | null {
if (x < 0 || y < 0 || x >= this.grid.width || y >= this.grid.height) {
return null;
}

    const index = y * this.grid.width + x;
    return this.grid.cells[index] ?? null;
}

private normalizeBrushSize(size: number): number {
if (size <= 1) {
return 1;
}
if (size <= 3) {
return 3;
}
return 5;
}
}



================================================
FILE: frontend/src/app/rooms/components/room-grid-preview.component.ts
================================================
import { NgFor, NgIf } from '@angular/common';
import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';
import type { RoomCellDto } from '../rooms.types';

export type RoomPlacementPreview = {
furniture_id: string;
x: number;
y: number;
width_cells: number;
height_cells: number;
color: string;
name?: string;
};

@Component({
selector: 'app-room-grid-preview',
standalone: true,
imports: [NgFor, NgIf],
template: `
    <div
      class="room-grid__wrap"
      [style.--cell-size.px]="cellSizePx"
      [style.--fill-color]="fillColor"
    >
      <div
        class="room-grid"
        [style.gridTemplateColumns]="gridTemplateColumns"
        [style.gridTemplateRows]="gridTemplateRows"
        role="grid"
        aria-label="Siatka pokoju"
      >
        <div
          class="room-grid__cell"
          *ngFor="let cell of gridCells; trackBy: trackByIndex"
          [class.room-grid__cell--filled]="cell.filled"
        ></div>
      </div>
      <div
        class="room-grid__overlay"
        [style.gridTemplateColumns]="gridTemplateColumns"
        [style.gridTemplateRows]="gridTemplateRows"
        aria-hidden="true"
        (mouseleave)="setInternalHover(null)"
      >
        <div
          class="room-grid__placement"
          *ngFor="let placement of placementCells; trackBy: trackByPlacementId"
          [style.gridColumn]="placement.gridColumn"
          [style.gridRow]="placement.gridRow"
          [style.--placement-color]="placement.color"
          [class.room-grid__placement--active]="
            placement.furnitureId === highlightedFurnitureId ||
            placement.furnitureId === hoveredFurnitureId ||
            placement.furnitureId === internalHoveredFurnitureId
          "
          (mouseenter)="setInternalHover(placement.furnitureId)"
          (mouseleave)="setInternalHover(null)"
          [attr.title]="placement.name ?? ''"
        >
          <span class="room-grid__label" *ngIf="placement.name">{{ placement.name }}</span>
        </div>
      </div>
    </div>
  `,
styles: [
`
.room-grid__wrap {
position: relative;
width: fit-content;
max-width: 100%;
}

      .room-grid {
        display: grid;
        gap: 2px;
        background: rgba(0, 0, 0, 0.08);
        padding: 8px;
        border-radius: 12px;
        width: fit-content;
        max-width: 100%;
        overflow: auto;
      }

      .room-grid__overlay {
        position: absolute;
        inset: 0;
        display: grid;
        gap: 2px;
        padding: 8px;
        pointer-events: auto;
      }

      .room-grid__cell {
        width: var(--cell-size);
        height: var(--cell-size);
        background: #fff;
        border-radius: 2px;
      }

      .room-grid__cell--filled {
        background: var(--fill-color);
      }

      .room-grid__placement {
        position: relative;
        background: var(--placement-color);
        border-radius: 4px;
        opacity: 0.6;
        border: 2px solid rgba(0, 0, 0, 0.35);
        box-sizing: border-box;
        pointer-events: auto;
      }

      .room-grid__placement--active {
        opacity: 0.9;
        border-color: rgba(31, 31, 28, 0.8);
        box-shadow: 0 0 0 2px rgba(31, 31, 28, 0.2);
      }

      .room-grid__label {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        padding: 2px 8px;
        border-radius: 999px;
        background: rgba(31, 31, 28, 0.9);
        color: #f8f6ef;
        font-size: 11px;
        letter-spacing: 0.2px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
        white-space: nowrap;
      }

      .room-grid__placement--active .room-grid__label {
        opacity: 1;
      }
    `,
],
})
export class RoomGridPreviewComponent implements OnChanges {
@Input() cells: RoomCellDto[] = [];
@Input() width?: number;
@Input() height?: number;
@Input() cellSizePx = 16;
@Input() fillColor = '#212121';
@Input() placements: RoomPlacementPreview[] = [];
@Input() highlightedFurnitureId?: string;
@Input() hoveredFurnitureId?: string;
@Input() resetHoverToken = 0;

gridCells: Array<{ filled: boolean }> = [];
gridTemplateColumns = '';
gridTemplateRows = '';
placementCells: Array<{
furnitureId: string;
gridColumn: string;
gridRow: string;
color: string;
name?: string;
}> = [];
internalHoveredFurnitureId?: string;
private lastResetToken = 0;

ngOnChanges(changes: SimpleChanges): void {
if (changes['resetHoverToken'] && this.resetHoverToken !== this.lastResetToken) {
this.internalHoveredFurnitureId = undefined;
this.lastResetToken = this.resetHoverToken;
}

    const grid = this.getGridSpec();
    const filled = new Set(this.cells.map((cell) => `${cell.x}:${cell.y}`));

    this.gridTemplateColumns = `repeat(${grid.safeWidth}, var(--cell-size))`;
    this.gridTemplateRows = `repeat(${grid.safeHeight}, var(--cell-size))`;
    this.gridCells = Array.from({ length: grid.safeWidth * grid.safeHeight }, (_, index) => {
      const x = grid.safeWidth === 0 ? 0 : index % grid.safeWidth;
      const y = grid.safeWidth === 0 ? 0 : Math.floor(index / grid.safeWidth);
      const sourceX = x - grid.offsetX;
      const sourceY = y - grid.offsetY;
      return { filled: filled.has(`${sourceX}:${sourceY}`) };
    });

    this.placementCells = this.placements.map((placement) => {
      const colStart = placement.x + grid.offsetX + 1;
      const rowStart = placement.y + grid.offsetY + 1;
      return {
        furnitureId: placement.furniture_id,
        gridColumn: `${colStart} / span ${placement.width_cells}`,
        gridRow: `${rowStart} / span ${placement.height_cells}`,
        color: placement.color,
        name: placement.name,
      };
    });
}

trackByIndex(index: number): number {
return index;
}

trackByPlacementId(_: number, placement: { furnitureId: string }): string {
return placement.furnitureId;
}

setInternalHover(furnitureId: string | null): void {
this.internalHoveredFurnitureId = furnitureId ?? undefined;
}

private getGridSpec(): { safeWidth: number; safeHeight: number; offsetX: number; offsetY: number } {
const bounds = this.getBounds();
if (!bounds) {
const safeWidth = Math.max(0, Math.floor(this.width ?? 0));
const safeHeight = Math.max(0, Math.floor(this.height ?? 0));
return { safeWidth, safeHeight, offsetX: 0, offsetY: 0 };
}

    const widthWithPadding = bounds.width + 4;
    const heightWithPadding = bounds.height + 4;

    return {
      safeWidth: Math.max(0, Math.floor(widthWithPadding)),
      safeHeight: Math.max(0, Math.floor(heightWithPadding)),
      offsetX: 2 - bounds.minX,
      offsetY: 2 - bounds.minY,
    };
}

private getBounds(): { minX: number; minY: number; width: number; height: number } | null {
if (this.cells.length === 0) {
return null;
}

    const xs = this.cells.map((cell) => cell.x);
    const ys = this.cells.map((cell) => cell.y);
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);

    return {
      minX,
      minY,
      width: maxX - minX + 1,
      height: maxY - minY + 1,
    };
}
}



================================================
FILE: frontend/src/app/rooms/components/rooms-list-header.component.ts
================================================
import { Component, EventEmitter, Output } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';

@Component({
selector: 'app-rooms-list-header',
standalone: true,
imports: [MatButtonModule],
template: `
    <header class="rooms-list-header">
      <div>
        <h1>Twoje pokoje</h1>
        <p class="rooms-list-header__subtitle">Zarzadzaj przestrzenia i dodawaj nowe pokoje.</p>
      </div>
      <button mat-flat-button color="primary" type="button" (click)="create.emit()">
        Dodaj pokoj
      </button>
    </header>
  `,
styles: [
`
.rooms-list-header {
display: flex;
align-items: center;
justify-content: space-between;
gap: 16px;
}

      .rooms-list-header h1 {
        margin: 0 0 4px;
      }

      .rooms-list-header__subtitle {
        margin: 0;
        color: rgba(0, 0, 0, 0.6);
      }
    `,
],
})
export class RoomsListHeaderComponent {
@Output() create = new EventEmitter<void>();
}



================================================
FILE: frontend/src/app/rooms/components/rooms-list.component.ts
================================================
import { NgFor } from '@angular/common';
import { Component, EventEmitter, Input, Output } from '@angular/core';
import type { RoomListItemVM } from '../rooms.view-models';
import { RoomCardComponent } from './room-card.component';

@Component({
selector: 'app-rooms-list',
standalone: true,
imports: [NgFor, RoomCardComponent],
template: `
    <section class="rooms-list" aria-label="Lista pokojow">
      <app-room-card
        *ngFor="let room of rooms; trackBy: trackByRoomId"
        [room]="room"
        (open)="open.emit($event)"
        (edit)="edit.emit($event)"
        (delete)="delete.emit($event)"
      />
    </section>
  `,
styles: [
`
      .rooms-list {
        display: grid;
        gap: 16px;
      }
    `,
],
})
export class RoomsListComponent {
@Input({ required: true }) rooms: RoomListItemVM[] = [];
@Output() open = new EventEmitter<string>();
@Output() edit = new EventEmitter<string>();
@Output() delete = new EventEmitter<string>();

trackByRoomId(index: number, room: RoomListItemVM): string {
return room.id;
}
}



================================================
FILE: frontend/src/app/rooms/pages/room-details-page/room-details-page.component.html
================================================
<section class="room-details" *ngIf="state$ | async as state">
  <div class="room-details__loading" *ngIf="state.isLoading">
    <mat-progress-spinner diameter="32"></mat-progress-spinner>
    <span>Laduje pokoj...</span>
  </div>

  <section *ngIf="state.notFound && !state.isLoading" class="room-details__empty">
    <h1>Nie znaleziono pokoju</h1>
    <p>Sprawdz, czy link jest poprawny.</p>
    <button mat-stroked-button color="primary" routerLink="/rooms">Wroc do listy</button>
  </section>

  <section *ngIf="!state.notFound && state.room" class="room-details__content">
    <header class="room-details__header">
      <div class="room-details__title">
        <span class="room-details__color" [style.backgroundColor]="state.room.color"></span>
        <div>
          <h1>{{ state.room.name }}</h1>
        </div>
      </div>
      <button mat-flat-button color="primary" type="button" (click)="addFurniture(state.room.id)">
        Dodaj mebel
      </button>
    </header>

    <section class="room-details__grid">
      <app-room-grid-preview
        [cells]="state.cells"
        [cellSizePx]="16"
        [fillColor]="state.room.color"
        [placements]="state.placements"
        [highlightedFurnitureId]="isItemsDialogOpen ? undefined : highlightedFurnitureId"
        [hoveredFurnitureId]="hoveredFurnitureId"
        [resetHoverToken]="resetHoverToken"
      ></app-room-grid-preview>
      <p class="room-details__hint" *ngIf="state.cells.length === 0">
        Brak zapisanej siatki dla tego pokoju.
      </p>
    </section>

    <section class="room-details__furniture">
      <header class="room-details__section-header">
        <h2>Meble</h2>
        <span>{{ state.furniture.length }} szt.</span>
      </header>

      <p class="room-details__error" *ngIf="state.error">{{ describeError(state.error) }}</p>

      <app-furniture-list
        *ngIf="state.furniture.length > 0"
        [items]="state.furniture"
        [highlightedId]="highlightedFurnitureId"
        (open)="openFurniture(state.room.id, $event)"
        (edit)="editFurniture(state.room.id, $event)"
        (delete)="deleteFurniture($event)"
        (hover)="setHoveredFurniture($event)"
      ></app-furniture-list>

      <section class="room-details__empty" *ngIf="state.furniture.length === 0">
        <p>Brak mebli w tym pokoju.</p>
        <button mat-stroked-button color="primary" type="button" (click)="addFurniture(state.room.id)">
          Dodaj pierwszy mebel
        </button>
      </section>
    </section>
  </section>
</section>



================================================
FILE: frontend/src/app/rooms/pages/room-details-page/room-details-page.component.scss
================================================
.room-details {
display: grid;
gap: 24px;
}

.room-details__loading {
display: flex;
align-items: center;
gap: 12px;
color: rgba(0, 0, 0, 0.7);
}

.room-details__content {
display: grid;
gap: 24px;
}

.room-details__header {
display: flex;
justify-content: space-between;
gap: 16px;
align-items: center;
flex-wrap: wrap;
}

.room-details__title {
display: flex;
align-items: center;
gap: 16px;
}

.room-details__title h1 {
margin: 0 0 4px;
}

.room-details__title p {
margin: 0;
color: rgba(0, 0, 0, 0.6);
}

.room-details__color {
width: 16px;
height: 48px;
border-radius: 12px;
}

.room-details__grid {
padding: 16px;
border-radius: 16px;
background: #f7f7f7;
overflow: hidden;
}

.room-details__hint {
margin: 12px 0 0;
color: rgba(0, 0, 0, 0.6);
}

.room-details__furniture {
display: grid;
gap: 16px;
}

.room-details__section-header {
display: flex;
align-items: center;
justify-content: space-between;
gap: 12px;
}

.room-details__error {
padding: 12px 16px;
border-radius: 12px;
background: #fff4f4;
color: #8a2f2f;
border: 1px solid #f2c6c6;
}

.room-details__empty {
display: grid;
gap: 8px;
padding: 24px;
border-radius: 16px;
border: 1px dashed rgba(0, 0, 0, 0.2);
}

.room-details__empty h1 {
margin: 0;
}



================================================
FILE: frontend/src/app/rooms/pages/room-details-page/room-details-page.component.ts
================================================
import { AsyncPipe, NgIf } from '@angular/common';
import { Component, DestroyRef, OnInit, inject } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { MatButtonModule } from '@angular/material/button';
import { MatDialog, MatDialogModule } from '@angular/material/dialog';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { ActivatedRoute, Router, RouterLink } from '@angular/router';
import { firstValueFrom } from 'rxjs';
import { ApiError } from '../../../shared/api-error';
import { ConfirmDialogComponent } from '../../../shared/confirm-dialog/confirm-dialog.component';
import {
FurnitureFormDialogComponent,
type FurnitureFormResult,
} from '../../../furniture/components/furniture-form-dialog.component';
import { FurnitureListComponent } from '../../../furniture/components/furniture-list.component';
import { FurnitureItemsDialogComponent } from '../../../items/components/furniture-items-dialog.component';
import type { FurnitureListItemVM } from '../../../furniture/furniture.view-models';
import { RoomGridPreviewComponent } from '../../components/room-grid-preview.component';
import { RoomDetailsFacade, type CreateFurniturePayload, type FurniturePlacementVM } from '../../room-details.facade';

@Component({
selector: 'app-room-details-page',
standalone: true,
imports: [
AsyncPipe,
NgIf,
MatButtonModule,
MatDialogModule,
MatProgressSpinnerModule,
MatSnackBarModule,
RouterLink,
RoomGridPreviewComponent,
FurnitureListComponent,
],
templateUrl: './room-details-page.component.html',
styleUrls: ['./room-details-page.component.scss'],
})
export class RoomDetailsPageComponent implements OnInit {
private readonly facade = inject(RoomDetailsFacade);
private readonly route = inject(ActivatedRoute);
private readonly router = inject(Router);
private readonly dialog = inject(MatDialog);
private readonly snackBar = inject(MatSnackBar);
private readonly destroyRef = inject(DestroyRef);

readonly state$ = this.facade.state$;

highlightedFurnitureId?: string;
hoveredFurnitureId?: string;
isItemsDialogOpen = false;
resetHoverToken = 0;
private furnitureSnapshot: FurnitureListItemVM[] = [];
private placementSnapshot: FurniturePlacementVM[] = [];

constructor() {
this.facade.state$.pipe(takeUntilDestroyed(this.destroyRef)).subscribe((state) => {
this.furnitureSnapshot = state.furniture;
this.placementSnapshot = state.placements;
});

    this.route.queryParamMap
      .pipe(takeUntilDestroyed(this.destroyRef))
      .subscribe((params) => {
        this.highlightedFurnitureId = params.get('furnitureId') ?? undefined;
      });
}

async ngOnInit(): Promise<void> {
const roomId = this.route.snapshot.paramMap.get('roomId') ?? '';

    try {
      await this.facade.load(roomId);
    } catch (err: unknown) {
      this.showError(err);
    }
}

async addFurniture(roomId: string): Promise<void> {
const dialogRef = this.dialog.open(FurnitureFormDialogComponent, {
data: {
title: 'Dodaj mebel',
submitLabel: 'Zapisz',
roomId,
roomCells: this.facade.snapshotCells,
},
});

    const value = await firstValueFrom(dialogRef.afterClosed());
    if (!value) {
      return;
    }

    await this.applyCreateFurniture(roomId, value);
}

async editFurniture(roomId: string, furnitureId: string): Promise<void> {
const current = this.furnitureSnapshot.find((item) => item.id === furnitureId);
if (!current) {
return;
}

    const dialogRef = this.dialog.open(FurnitureFormDialogComponent, {
      data: {
        title: 'Edytuj mebel',
        submitLabel: 'Zapisz',
        value: {
          name: current.name,
          description: current.description ?? '',
          color: current.color,
        },
        roomId,
        roomCells: this.facade.snapshotCells,
        placement: this.placementSnapshot.find((item) => item.furniture_id === furnitureId),
      },
    });

    const value = await firstValueFrom(dialogRef.afterClosed());
    if (!value) {
      return;
    }

    try {
      await this.facade.updateFurniture(
        furnitureId,
        normalizeFurniturePayload(value),
        value.placement
      );
      this.snackBar.open('Mebel zaktualizowany.', 'Zamknij', { duration: 3000 });
    } catch (err: unknown) {
      this.showError(err);
    }
}

async deleteFurniture(furnitureId: string): Promise<void> {
const dialogRef = this.dialog.open(ConfirmDialogComponent, {
data: {
title: 'Usun mebel',
message: 'Czy na pewno chcesz usunac mebel? Znikna tez przypisane przedmioty.',
confirmText: 'Usun',
cancelText: 'Anuluj',
},
});

    const confirmed = await firstValueFrom(dialogRef.afterClosed());
    if (!confirmed) {
      return;
    }

    try {
      await this.facade.deleteFurniture(furnitureId);
      this.snackBar.open('Mebel zostal usuniety.', 'Zamknij', { duration: 3000 });
    } catch (err: unknown) {
      this.showError(err);
    }
}

openFurniture(roomId: string, furnitureId: string): void {
this.hoveredFurnitureId = undefined;
this.resetHoverToken += 1;
this.isItemsDialogOpen = true;
void this.router.navigate([], {
relativeTo: this.route,
queryParams: { furnitureId },
queryParamsHandling: 'merge',
});

    const current = this.furnitureSnapshot.find((item) => item.id === furnitureId);
    if (!current) {
      return;
    }

    const dialogRef = this.dialog.open(FurnitureItemsDialogComponent, {
      data: {
        furnitureId,
        furnitureName: current.name,
        roomId,
      },
      width: '720px',
      height: '50vh',
      maxWidth: '95vw',
    });

    dialogRef.afterClosed().subscribe(() => {
      this.highlightedFurnitureId = undefined;
      this.hoveredFurnitureId = undefined;
      this.isItemsDialogOpen = false;
      this.resetHoverToken += 1;
      void this.router.navigate([], {
        relativeTo: this.route,
        queryParams: { furnitureId: null },
        queryParamsHandling: 'merge',
      });
    });
}

setHoveredFurniture(furnitureId: string | null): void {
this.hoveredFurnitureId = furnitureId ?? undefined;
}

describeError(error: ApiError): string {
if (error.details?.['name']) {
return error.details['name'];
}

    return error.message;
}

private async applyCreateFurniture(roomId: string, value: FurnitureFormResult): Promise<void> {
try {
await this.facade.createFurniture(
roomId,
normalizeFurniturePayload(value),
value.placement
);
this.snackBar.open('Mebel dodany.', 'Zamknij', { duration: 3000 });
} catch (err: unknown) {
this.showError(err);
}
}

private showError(err: unknown): void {
const message = this.formatError(err);
this.snackBar.open(message, 'Zamknij', { duration: 4000 });
}

private formatError(error: unknown): string {
if (error instanceof ApiError) {
return this.describeError(error);
}

    if (error instanceof Error) {
      return error.message;
    }

    return 'Wystapil nieznany blad.';
}
}

function normalizeFurniturePayload(value: FurnitureFormResult): CreateFurniturePayload {
return {
name: value.name.trim(),
description: value.description.trim(),
color: value.color.trim(),
};
}



================================================
FILE: frontend/src/app/rooms/pages/room-editor-page/room-editor-page.component.html
================================================
<section class="room-editor" *ngIf="state$ | async as state">
  <header class="room-editor__header">
    <div>
      <h1>{{ isEdit ? 'Edytuj pokoj' : 'Nowy pokoj' }}</h1>
      <p>Wypelnij dane i zaznacz ksztalt pokoju na siatce.</p>
    </div>
    <a mat-stroked-button routerLink="/rooms">Wroc do listy</a>
  </header>

  <div class="room-editor__loading" *ngIf="state.isLoading">
    <mat-progress-spinner diameter="32"></mat-progress-spinner>
    <span>Laduje dane pokoju...</span>
  </div>

  <section *ngIf="state.notFound && !state.isLoading" class="room-editor__empty">
    <h2>Nie znaleziono pokoju</h2>
    <p>Sprawdz, czy link jest poprawny.</p>
  </section>

  <section class="room-editor__content" *ngIf="!state.notFound">
    <app-room-form [value]="formValue" (valueChange)="updateForm($event)"></app-room-form>

    <div class="room-editor__grid">
      <h2>Siatka pokoju</h2>
      <p class="room-editor__hint">
        Kliknij komorki, aby je zaznaczyc. Kolejne komorki musza sie stykac.
      </p>
      <app-room-grid-editor [grid]="gridState" (setCell)="setCell($event)"></app-room-grid-editor>
      <p class="room-editor__error" *ngIf="validationError">{{ validationError }}</p>
    </div>

    <app-room-editor-actions
      [canSave]="canSave()"
      [isSaving]="state.isSaving"
      (save)="save()"
      (cancel)="cancel()"
    ></app-room-editor-actions>
  </section>
</section>



================================================
FILE: frontend/src/app/rooms/pages/room-editor-page/room-editor-page.component.scss
================================================
.room-editor {
display: grid;
gap: 24px;
}

.room-editor__header {
display: flex;
justify-content: space-between;
gap: 16px;
align-items: center;
flex-wrap: wrap;
}

.room-editor__header h1 {
margin: 0 0 4px;
}

.room-editor__header p {
margin: 0;
color: rgba(0, 0, 0, 0.6);
}

.room-editor__loading {
display: flex;
align-items: center;
gap: 12px;
color: rgba(0, 0, 0, 0.7);
}

.room-editor__content {
display: grid;
gap: 24px;
}

.room-editor__grid {
display: grid;
gap: 12px;
padding: 16px;
border-radius: 16px;
background: #f7f7f7;
}

.room-editor__brush {
justify-self: start;
}

.room-editor__hint {
margin: 0;
color: rgba(0, 0, 0, 0.6);
}

.room-editor__error {
margin: 0;
padding: 10px 12px;
border-radius: 12px;
background: #fff4f4;
color: #8a2f2f;
border: 1px solid #f2c6c6;
}

.room-editor__empty {
display: grid;
gap: 8px;
padding: 24px;
border-radius: 16px;
border: 1px dashed rgba(0, 0, 0, 0.2);
}



================================================
FILE: frontend/src/app/rooms/pages/room-editor-page/room-editor-page.component.ts
================================================
import { AsyncPipe, NgIf } from '@angular/common';
import { Component, DestroyRef, OnInit, inject } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { MatButtonModule } from '@angular/material/button';
import { MatButtonToggleModule } from '@angular/material/button-toggle';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { ActivatedRoute, Router, RouterLink } from '@angular/router';
import { ApiError } from '../../../shared/api-error';
import { RoomEditorActionsComponent } from '../../components/room-editor-actions.component';
import { RoomFormComponent, type RoomFormValue } from '../../components/room-form.component';
import { RoomGridEditorComponent } from '../../components/room-grid-editor.component';
import { RoomEditorFacade } from '../../room-editor.facade';
import {
RoomGridEditorService,
type RoomGridCell,
type RoomGridState,
} from '../../room-grid-editor.service';
import type { CreateRoomCommand, UpdateRoomCommand } from '../../rooms.types';

@Component({
selector: 'app-room-editor-page',
standalone: true,
imports: [
AsyncPipe,
NgIf,
MatButtonModule,
MatButtonToggleModule,
MatProgressSpinnerModule,
MatSnackBarModule,
RouterLink,
RoomFormComponent,
RoomGridEditorComponent,
RoomEditorActionsComponent,
],
template: `
<section class="room-editor" *ngIf="state$ | async as state">
<header class="room-editor__header">
<div>
<h1>{{ isEdit ? 'Edytuj pokoj' : 'Nowy pokoj' }}</h1>
<p>Wypelnij dane i zaznacz ksztalt pokoju na siatce.</p>
</div>
<a mat-stroked-button routerLink="/rooms">Wroc do listy</a>
</header>

      <div class="room-editor__loading" *ngIf="state.isLoading">
        <mat-progress-spinner diameter="32"></mat-progress-spinner>
        <span>Laduje dane pokoju...</span>
      </div>

      <section *ngIf="state.notFound && !state.isLoading" class="room-editor__empty">
        <h2>Nie znaleziono pokoju</h2>
        <p>Sprawdz, czy link jest poprawny.</p>
      </section>

      <section class="room-editor__content" *ngIf="!state.notFound">
        <app-room-form [value]="formValue" (valueChange)="updateForm($event)"></app-room-form>

        <div class="room-editor__grid">
          <h2>Siatka pokoju</h2>
          <p class="room-editor__hint">
            Kliknij komorki, aby je zaznaczyc. Kolejne komorki musza sie stykac.
          </p>
          <mat-button-toggle-group
            class="room-editor__brush"
            [value]="brushSize"
            (valueChange)="setBrushSize($event)"
            aria-label="Rozmiar pedzla"
          >
            <mat-button-toggle [value]="1">1x1</mat-button-toggle>
            <mat-button-toggle [value]="3">3x3</mat-button-toggle>
            <mat-button-toggle [value]="5">5x5</mat-button-toggle>
          </mat-button-toggle-group>
          <app-room-grid-editor
            [grid]="gridState"
            [fillColor]="formValue.color"
            [brushSize]="brushSize"
            (setCell)="setCell($event)"
          ></app-room-grid-editor>
          <p class="room-editor__error" *ngIf="validationError">{{ validationError }}</p>
        </div>

        <app-room-editor-actions
          [canSave]="canSave()"
          [isSaving]="state.isSaving"
          (save)="save()"
          (cancel)="cancel()"
        ></app-room-editor-actions>
      </section>
    </section>
`,
styleUrls: ['./room-editor-page.component.scss'],
})
export class RoomEditorPageComponent implements OnInit {
private readonly facade = inject(RoomEditorFacade);
private readonly gridService = inject(RoomGridEditorService);
private readonly route = inject(ActivatedRoute);
private readonly router = inject(Router);
private readonly snackBar = inject(MatSnackBar);
private readonly destroyRef = inject(DestroyRef);

readonly state$ = this.facade.state$;

formValue: RoomFormValue = {
name: '',
color: '#aabbcc',
};

gridState: RoomGridState = this.gridService.createGrid(40, 40, false);
brushSize = 1;

isEdit = false;
roomId = '';
validationError: string | null = null;

constructor() {
this.facade.state$
.pipe(takeUntilDestroyed(this.destroyRef))
.subscribe((state) => {
if (state.room) {
this.formValue = { name: state.room.name, color: state.room.color };
const nextGrid = this.gridService.createGrid(40, 40, false);
this.gridState = this.gridService.applyCells(nextGrid, state.cells);
}
});
}

async ngOnInit(): Promise<void> {
this.route.paramMap.pipe(takeUntilDestroyed(this.destroyRef)).subscribe((params) => {
const roomId = params.get('roomId');
void this.handleRoute(roomId);
});
}

updateForm(value: RoomFormValue): void {
this.formValue = value;
}

setCell(payload: { cell: RoomGridCell; filled: boolean }): void {
const { cell, filled } = payload;
this.gridState = this.gridService.setCell(this.gridState, cell, filled);
}

setBrushSize(size: number): void {
this.brushSize = size;
}

async save(): Promise<void> {
this.validationError = null;
const filledCells = this.gridService.getFilledCells(this.gridState);
if (filledCells.length === 0) {
this.validationError = 'Wybierz przynajmniej jedna komorke siatki.';
return;
}

    const payload = this.buildPayload();

    try {
      if (this.isEdit) {
        await this.facade.updateRoom(this.roomId, payload as UpdateRoomCommand);
        await this.facade.replaceRoomCells(this.roomId, filledCells);
        this.snackBar.open('Pokoj zaktualizowany.', 'Zamknij', { duration: 3000 });
      } else {
        const created = await this.facade.createRoom(payload as CreateRoomCommand);
        await this.facade.replaceRoomCells(created.id, filledCells);
        this.snackBar.open('Pokoj utworzony.', 'Zamknij', { duration: 3000 });
        void this.router.navigate(['/rooms', created.id]);
        return;
      }

      void this.router.navigate(['/rooms', this.roomId]);
    } catch (err: unknown) {
      this.showError(err);
    }
}

cancel(): void {
if (this.isEdit) {
void this.router.navigate(['/rooms', this.roomId]);
return;
}

    void this.router.navigate(['/rooms']);
}

canSave(): boolean {
return this.formValue.name.trim().length > 0 && this.formValue.color.trim().length > 0;
}

private buildPayload(): CreateRoomCommand {
return {
name: this.formValue.name.trim(),
color: this.formValue.color.trim(),
};
}

private showError(err: unknown): void {
const message = this.formatError(err);
this.snackBar.open(message, 'Zamknij', { duration: 4000 });
}

private formatError(error: unknown): string {
if (error instanceof ApiError) {
return error.details?.['name'] ?? error.message;
}

    if (error instanceof Error) {
      return error.message;
    }

    return 'Wystapil nieznany blad.';
}

private async handleRoute(roomId: string | null): Promise<void> {
if (roomId) {
this.isEdit = true;
this.roomId = roomId;
try {
await this.facade.load(roomId);
} catch (err: unknown) {
this.showError(err);
}
return;
}

    this.isEdit = false;
    this.roomId = '';
    this.validationError = null;
    this.formValue = {
      name: '',
      color: '#aabbcc',
    };
    this.gridState = this.gridService.createGrid(40, 40, false);
    this.facade.reset();
}
}



================================================
FILE: frontend/src/app/rooms/pages/rooms-list-page/rooms-list-page.component.html
================================================
<section class="rooms-list-page">
  <app-rooms-list-header (create)="createRoom()" />

<ng-container *ngIf="state$ | async as state">
<section class="rooms-list-page__content">
<div class="rooms-list-page__loading" *ngIf="state.isLoading">
<mat-progress-spinner diameter="32"></mat-progress-spinner>
<span>Laduje pokoje...</span>
</div>

      <p class="rooms-list-page__error" *ngIf="state.error">
        {{ describeError(state.error) }}
      </p>

      <app-rooms-list
        *ngIf="!state.isLoading && state.rooms.length > 0"
        [rooms]="state.rooms"
        (open)="openRoom($event)"
        (edit)="editRoom($event)"
        (delete)="confirmDelete($event)"
      />

      <section class="rooms-list-page__empty" *ngIf="!state.isLoading && state.rooms.length === 0">
        <h2>Brak pokojow</h2>
        <p>Dodaj pierwszy pokoj, aby zaczac mapowac dom.</p>
        <button mat-stroked-button color="primary" type="button" (click)="createRoom()">
          Dodaj pokoj
        </button>
      </section>
    </section>
  </ng-container>
</section>



================================================
FILE: frontend/src/app/rooms/pages/rooms-list-page/rooms-list-page.component.scss
================================================
.rooms-list-page {
display: grid;
gap: 24px;
}

.rooms-list-page__content {
display: grid;
gap: 20px;
}

.rooms-list-page__loading {
display: flex;
align-items: center;
gap: 12px;
color: rgba(0, 0, 0, 0.7);
}

.rooms-list-page__error {
padding: 12px 16px;
border-radius: 12px;
background: #fff4f4;
color: #8a2f2f;
border: 1px solid #f2c6c6;
}

.rooms-list-page__empty {
display: grid;
gap: 8px;
padding: 24px;
border-radius: 16px;
border: 1px dashed rgba(0, 0, 0, 0.2);
}

.rooms-list-page__empty h2 {
margin: 0;
}



================================================
FILE: frontend/src/app/rooms/pages/rooms-list-page/rooms-list-page.component.ts
================================================
import { AsyncPipe, NgIf } from '@angular/common';
import { Component, DestroyRef, OnInit, inject } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { MatButtonModule } from '@angular/material/button';
import { MatDialog, MatDialogModule } from '@angular/material/dialog';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { Router } from '@angular/router';
import { firstValueFrom } from 'rxjs';
import { ApiError } from '../../../shared/api-error';
import { ConfirmDialogComponent } from '../../../shared/confirm-dialog/confirm-dialog.component';
import { RoomsListFacade } from '../../rooms-list.facade';
import type { RoomListItemVM } from '../../rooms.view-models';
import { RoomsListComponent } from '../../components/rooms-list.component';
import { RoomsListHeaderComponent } from '../../components/rooms-list-header.component';

@Component({
selector: 'app-rooms-list-page',
standalone: true,
imports: [
AsyncPipe,
NgIf,
MatButtonModule,
MatDialogModule,
MatProgressSpinnerModule,
MatSnackBarModule,
RoomsListHeaderComponent,
RoomsListComponent,
],
templateUrl: './rooms-list-page.component.html',
styleUrls: ['./rooms-list-page.component.scss'],
})
export class RoomsListPageComponent implements OnInit {
private readonly facade = inject(RoomsListFacade);
private readonly router = inject(Router);
private readonly dialog = inject(MatDialog);
private readonly snackBar = inject(MatSnackBar);
private readonly destroyRef = inject(DestroyRef);

readonly state$ = this.facade.state$;

private roomsSnapshot: RoomListItemVM[] = [];

constructor() {
this.facade.state$
.pipe(takeUntilDestroyed(this.destroyRef))
.subscribe((state) => (this.roomsSnapshot = state.rooms));
}

async ngOnInit(): Promise<void> {
try {
await this.facade.loadRooms();
} catch (err: unknown) {
this.showError(err);
}
}

createRoom(): void {
void this.router.navigate(['/rooms/new']);
}

openRoom(roomId: string): void {
void this.router.navigate(['/rooms', roomId]);
}

editRoom(roomId: string): void {
void this.router.navigate(['/rooms', roomId, 'edit']);
}

async confirmDelete(roomId: string): Promise<void> {
const room = this.roomsSnapshot.find((item) => item.id === roomId);
const dialogRef = this.dialog.open(ConfirmDialogComponent, {
data: {
title: 'Usun pokoj',
message: room
? `Czy na pewno chcesz usunac pokoj "${room.name}"?`
: 'Czy na pewno chcesz usunac ten pokoj?',
confirmText: 'Usun',
cancelText: 'Anuluj',
},
});

    const confirmed = await firstValueFrom(dialogRef.afterClosed());
    if (!confirmed) {
      return;
    }

    try {
      await this.facade.deleteRoom(roomId);
      this.snackBar.open('Pokoj zostal usuniety.', 'Zamknij', { duration: 3000 });
    } catch (err: unknown) {
      this.showError(err);
    }
}

describeError(error: ApiError): string {
if (error.details?.['name']) {
return error.details['name'];
}

    return error.message;
}

private showError(err: unknown): void {
const message = this.formatError(err);
this.snackBar.open(message, 'Zamknij', { duration: 4000 });
}

private formatError(error: unknown): string {
if (error instanceof ApiError) {
return this.describeError(error);
}

    if (error instanceof Error) {
      return error.message;
    }

    return 'Wystapil nieznany blad.';
}
}



================================================
FILE: frontend/src/app/search/search.api.ts
================================================
import { Injectable, inject } from '@angular/core';
import { SupabaseService } from '../../db/supabase.service';
import { ApiError } from '../shared/api-error';
import { mapSearchItemsPostgrestError } from './search.errors';
import type { SearchItemsQuery, SearchItemsResponseDto } from './search.types';
import { SEARCH_SELECT } from './search.types';
import { validateSearchItemsQuery } from './search.validation';

type ItemSearchRow = {
id: string;
name: string;
furniture: { id: string; name: string; room: { id: string; name: string } | null } | null;
};

@Injectable({
providedIn: 'root',
})
export class SearchApi {
private readonly supabase = inject(SupabaseService);

async searchItems(query: SearchItemsQuery): Promise<SearchItemsResponseDto> {
const validationErrors = validateSearchItemsQuery(query);
if (validationErrors) {
throw ApiError.validation(validationErrors);
}

    const trimmed = query.q.trim();
    let request = this.supabase
      .getClient()
      .from('items')
      .select(SEARCH_SELECT)
      .ilike('name', `%${trimmed}%`);

    if (query.sort === 'name' || query.sort === 'created_at') {
      request = request.order(query.sort, { ascending: query.order !== 'desc' });
    }

    if (query.limit !== undefined) {
      const start = query.offset ?? 0;
      const end = start + query.limit - 1;
      request = request.range(start, end);
    }

    const { data, error, status } = await request;

    if (error) {
      throw mapSearchItemsPostgrestError(error, status);
    }

    const rows = (data ?? []) as ItemSearchRow[];
    const results = rows
      .filter((row) => row.furniture && row.furniture.room)
      .map((row) => ({
        item_id: row.id,
        item_name: row.name,
        furniture: { id: row.furniture!.id, name: row.furniture!.name },
        room: { id: row.furniture!.room!.id, name: row.furniture!.room!.name },
      }));

    return { data: results };
}
}



================================================
FILE: frontend/src/app/search/search.errors.ts
================================================
import type { PostgrestError } from '@supabase/postgrest-js';
import { ApiError } from '../shared/api-error';

export function mapSearchItemsPostgrestError(error: PostgrestError, status?: number): ApiError {
if (status === 401) {
return ApiError.unauthorized(error.message);
}

if (status === 400 || error.code === '22P02') {
return ApiError.badRequest(error.message, undefined, error);
}

return new ApiError({
status: status ?? 500,
code: 'SUPABASE_ERROR',
message: error.message,
cause: error,
});
}



================================================
FILE: frontend/src/app/search/search.types.ts
================================================
import type { Tables } from '../../db/database.types';

type ItemRow = Tables<'items'>;
type FurnitureRow = Tables<'furniture'>;
type RoomRow = Tables<'rooms'>;

export type SearchOrderBy = 'relevance' | 'name' | 'created_at';
export type SearchOrderDirection = 'asc' | 'desc';

export type SearchItemsQuery = {
q: string;
limit?: number;
offset?: number;
sort?: SearchOrderBy;
order?: SearchOrderDirection;
};

export type SearchItemResultDto = {
item_id: ItemRow['id'];
item_name: ItemRow['name'];
furniture: Pick<FurnitureRow, 'id' | 'name'>;
room: Pick<RoomRow, 'id' | 'name'>;
};

export type SearchItemsResponseDto = {
data: SearchItemResultDto[];
};

export const SEARCH_SELECT =
'id,name,furniture:furniture(id,name,room:rooms(id,name))' as const;



================================================
FILE: frontend/src/app/search/search.validation.ts
================================================
import type { SearchItemsQuery } from './search.types';

type SearchField = keyof SearchItemsQuery;

function isInteger(value: unknown): value is number {
return typeof value === 'number' && Number.isInteger(value);
}

export function validateSearchItemsQuery(query: SearchItemsQuery): Record<string, string> | null {
const errors: Partial<Record<SearchField, string>> = {};

const trimmed = query.q.trim();
if (trimmed.length === 0) {
errors.q = 'Query is required';
}

if (query.limit !== undefined) {
if (!isInteger(query.limit) || query.limit < 1 || query.limit > 200) {
errors.limit = 'limit must be an integer between 1 and 200';
}
}

if (query.offset !== undefined) {
if (!isInteger(query.offset) || query.offset < 0) {
errors.offset = 'offset must be an integer >= 0';
} else if (query.limit === undefined) {
errors.offset = 'offset requires limit to be set';
}
}

if (
query.sort !== undefined &&
query.sort !== 'relevance' &&
query.sort !== 'name' &&
query.sort !== 'created_at'
) {
errors.sort = 'sort must be one of: relevance, name, created_at';
}

if (query.order !== undefined && query.order !== 'asc' && query.order !== 'desc') {
errors.order = 'order must be one of: asc, desc';
}

if (Object.keys(errors).length === 0) {
return null;
}

return errors as Record<string, string>;
}



================================================
FILE: frontend/src/app/search/search.view-models.ts
================================================
import type { SearchItemResultDto } from './search.types';

export type SearchResultVM = {
itemId: string;
itemName: string;
furnitureId: string;
furnitureName: string;
roomId: string;
roomName: string;
};

export type SearchStateVM = {
query: string;
results: SearchResultVM[];
isLoading: boolean;
hasSearched: boolean;
error?: string;
};

export type SearchFormVM = {
value: string;
error?: string;
};

export type SearchFormErrors = {
q?: string;
};

export function mapSearchResult(dto: SearchItemResultDto): SearchResultVM {
return {
itemId: dto.item_id,
itemName: dto.item_name,
furnitureId: dto.furniture.id,
furnitureName: dto.furniture.name,
roomId: dto.room.id,
roomName: dto.room.name,
};
}



================================================
FILE: frontend/src/app/search/components/search-empty-state.component.ts
================================================
import { Component } from '@angular/core';

@Component({
selector: 'app-search-empty-state',
standalone: true,
template: `
    <section class="search-empty">
      <h2>Brak wynikow</h2>
      <p>Sprobuj uzyc innej nazwy lub mniej szczegolnego zapytania.</p>
    </section>
  `,
styles: [
`
.search-empty {
display: grid;
gap: 6px;
padding: 24px;
border-radius: 16px;
border: 1px dashed rgba(31, 31, 28, 0.2);
background: rgba(255, 255, 255, 0.6);
}

      .search-empty h2 {
        margin: 0;
      }

      .search-empty p {
        margin: 0;
        color: rgba(31, 31, 28, 0.7);
      }
    `,
],
})
export class SearchEmptyStateComponent {}



================================================
FILE: frontend/src/app/search/components/search-form.component.ts
================================================
import { NgIf } from '@angular/common';
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';

@Component({
selector: 'app-search-form',
standalone: true,
imports: [NgIf, MatButtonModule, MatFormFieldModule, MatInputModule],
template: `
    <form class="search-form" (submit)="onSubmit($event)">
      <mat-form-field appearance="outline" class="search-form__field">
        <mat-label>Wyszukaj przedmiot</mat-label>
        <input
          matInput
          [value]="query"
          (input)="onInput($event)"
          [disabled]="disabled"
          maxlength="200"
        />
        <mat-error *ngIf="error">{{ error }}</mat-error>
      </mat-form-field>
      <button
        mat-flat-button
        color="primary"
        type="submit"
        [disabled]="disabled || !isQueryValid"
      >
        Szukaj
      </button>
    </form>
  `,
styles: [
`
.search-form {
display: grid;
grid-template-columns: minmax(0, 1fr) auto;
gap: 12px;
align-items: start;
}

      .search-form__field {
        width: 100%;
      }

      @media (max-width: 720px) {
        .search-form {
          grid-template-columns: minmax(0, 1fr);
        }

        .search-form button {
          width: 100%;
        }
      }
    `,
],
})
export class SearchFormComponent {
@Input() query = '';
@Input() disabled = false;
@Input() error?: string;
@Output() update = new EventEmitter<string>();
@Output() submitQuery = new EventEmitter<string>();

get isQueryValid(): boolean {
return this.query.trim().length > 0;
}

onInput(event: Event): void {
const target = event.target as HTMLInputElement;
this.update.emit(target.value);
}

onSubmit(event: Event): void {
event.preventDefault();
if (!this.isQueryValid) {
return;
}
this.submitQuery.emit(this.query);
}
}



================================================
FILE: frontend/src/app/search/components/search-result-item.component.ts
================================================
import { Component, EventEmitter, Input, Output } from '@angular/core';
import type { SearchResultVM } from '../search.view-models';

@Component({
selector: 'app-search-result-item',
standalone: true,
template: `
    <button class="search-result" type="button" (click)="open.emit(item)">
      <div class="search-result__title">{{ item.itemName }}</div>
      <div class="search-result__meta">
        <span>Mebel: {{ item.furnitureName }}</span>
        <span>Pokoj: {{ item.roomName }}</span>
      </div>
    </button>
  `,
styles: [
`
.search-result {
display: grid;
gap: 4px;
padding: 12px 16px;
border-radius: 12px;
border: 1px solid rgba(31, 31, 28, 0.12);
background: #fff;
text-align: left;
cursor: pointer;
transition: border-color 0.2s ease, box-shadow 0.2s ease;
}

      .search-result:hover {
        border-color: rgba(31, 31, 28, 0.3);
        box-shadow: 0 6px 12px rgba(31, 31, 28, 0.08);
      }

      .search-result__title {
        font-weight: 600;
      }

      .search-result__meta {
        display: flex;
        gap: 16px;
        color: rgba(31, 31, 28, 0.7);
        font-size: 13px;
      }

      @media (max-width: 720px) {
        .search-result__meta {
          flex-direction: column;
          gap: 4px;
        }
      }
    `,
],
})
export class SearchResultItemComponent {
@Input({ required: true }) item!: SearchResultVM;
@Output() open = new EventEmitter<SearchResultVM>();
}



================================================
FILE: frontend/src/app/search/components/search-results-list.component.ts
================================================
import { NgFor } from '@angular/common';
import { Component, EventEmitter, Input, Output } from '@angular/core';
import type { SearchResultVM } from '../search.view-models';
import { SearchResultItemComponent } from './search-result-item.component';

@Component({
selector: 'app-search-results-list',
standalone: true,
imports: [NgFor, SearchResultItemComponent],
template: `
    <section class="search-results" aria-label="Wyniki wyszukiwania">
      <app-search-result-item
        *ngFor="let item of items; trackBy: trackByResultId"
        [item]="item"
        (open)="open.emit($event)"
      />
    </section>
  `,
styles: [
`
      .search-results {
        display: grid;
        gap: 12px;
      }
    `,
],
})
export class SearchResultsListComponent {
@Input({ required: true }) items: SearchResultVM[] = [];
@Output() open = new EventEmitter<SearchResultVM>();

trackByResultId(_: number, item: SearchResultVM): string {
return item.itemId;
}
}



================================================
FILE: frontend/src/app/search/pages/search-page/search-page.component.html
================================================
<section class="search-page">
  <header class="search-page__header">
    <div>
      <h1>Wyszukiwanie przedmiotow</h1>
      <p>Znajdz przedmiot i przejdz do mebla, w ktorym sie znajduje.</p>
    </div>
  </header>

<app-search-form
[query]="state.query"
[disabled]="state.isLoading"
[error]="formError"
(update)="updateQuery($event)"
(submitQuery)="submitQuery($event)"
></app-search-form>

  <section class="search-page__loading" *ngIf="state.isLoading">
    <mat-progress-spinner diameter="28" mode="indeterminate"></mat-progress-spinner>
    <span>Wyszukiwanie...</span>
  </section>

<app-search-results-list
*ngIf="!state.isLoading && state.results.length > 0"
[items]="state.results"
(open)="openResult($event)"
></app-search-results-list>

<app-search-empty-state
*ngIf="!state.isLoading && state.hasSearched && state.results.length === 0"
></app-search-empty-state>
</section>



================================================
FILE: frontend/src/app/search/pages/search-page/search-page.component.scss
================================================
.search-page {
display: grid;
gap: 20px;
max-width: 760px;
}

.search-page__header {
display: grid;
gap: 6px;
}

.search-page__header h1 {
margin: 0;
font-size: 28px;
}

.search-page__header p {
margin: 0;
color: rgba(31, 31, 28, 0.7);
}

.search-page__loading {
display: flex;
align-items: center;
gap: 12px;
color: rgba(31, 31, 28, 0.7);
}



================================================
FILE: frontend/src/app/search/pages/search-page/search-page.component.ts
================================================
import { NgIf } from '@angular/common';
import { ChangeDetectorRef, Component, NgZone, inject } from '@angular/core';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { Router } from '@angular/router';
import { ApiError } from '../../../shared/api-error';
import { SearchApi } from '../../search.api';
import { validateSearchItemsQuery } from '../../search.validation';
import type { SearchItemsQuery } from '../../search.types';
import {
mapSearchResult,
type SearchResultVM,
type SearchStateVM,
} from '../../search.view-models';
import { SearchEmptyStateComponent } from '../../components/search-empty-state.component';
import { SearchFormComponent } from '../../components/search-form.component';
import { SearchResultsListComponent } from '../../components/search-results-list.component';

@Component({
selector: 'app-search-page',
standalone: true,
imports: [
NgIf,
MatProgressSpinnerModule,
MatSnackBarModule,
SearchFormComponent,
SearchResultsListComponent,
SearchEmptyStateComponent,
],
templateUrl: './search-page.component.html',
styleUrls: ['./search-page.component.scss'],
})
export class SearchPageComponent {
private readonly searchApi = inject(SearchApi);
private readonly snackBar = inject(MatSnackBar);
private readonly router = inject(Router);
private readonly zone = inject(NgZone);
private readonly cdr = inject(ChangeDetectorRef);

state: SearchStateVM = {
query: '',
results: [],
isLoading: false,
hasSearched: false,
};
formError?: string;

updateQuery(value: string): void {
this.patchState({ query: value });
if (this.formError) {
this.formError = undefined;
}
}

async submitQuery(query: string): Promise<void> {
const trimmed = query.trim();
const request: SearchItemsQuery = {
q: trimmed,
limit: 20,
sort: 'relevance',
};
const validationErrors = validateSearchItemsQuery(request);
if (validationErrors) {
this.formError = this.describeValidation(validationErrors);
return;
}

    this.patchState({ isLoading: true });
    let results: SearchResultVM[] | null = null;
    try {
      const response = await this.searchApi.searchItems(request);
      results = response.data.map(mapSearchResult);
      this.patchState({ query: trimmed, results });
    } catch (err: unknown) {
      this.handleError(err);
    } finally {
      this.patchState({ isLoading: false, hasSearched: true });
    }
}

openResult(result: SearchResultVM): void {
void this.router.navigate(['/rooms', result.roomId], {
queryParams: { furnitureId: result.furnitureId },
});
}

private handleError(err: unknown): void {
if (err instanceof ApiError && err.code === 'VALIDATION_ERROR') {
this.formError = this.describeValidation(err.details ?? {});
return;
}

    const message = this.formatError(err);
    this.snackBar.open(message, 'Zamknij', { duration: 4000 });
}

private describeValidation(details: Record<string, string>): string {
if (details['q']) {
return 'Wpisz fraze do wyszukania.';
}

    const firstError = Object.values(details)[0];
    return firstError ?? 'Niepoprawne zapytanie.';
}

private formatError(error: unknown): string {
if (error instanceof ApiError) {
if (error.code === 'UNAUTHORIZED') {
return 'Brak autoryzacji.';
}

      if (error.code === 'BAD_REQUEST') {
        return 'Niepoprawne zapytanie.';
      }

      return error.message;
    }

    if (error instanceof Error) {
      return error.message;
    }

    return 'Wystapil nieznany blad.';
}

private patchState(patch: Partial<SearchStateVM>): void {
this.zone.run(() => {
this.state = { ...this.state, ...patch };
this.cdr.detectChanges();
});
}
}



================================================
FILE: frontend/src/app/shared/api-error.ts
================================================
export type ApiErrorCode =
| 'UNAUTHORIZED'
| 'BAD_REQUEST'
| 'VALIDATION_ERROR'
| 'NOT_FOUND'
| 'ROOM_NAME_CONFLICT'
| 'DB_CONSTRAINT_VIOLATION'
| 'SUPABASE_ERROR';

export class ApiError extends Error {
readonly status: number;
readonly code: ApiErrorCode;
readonly details?: Record<string, string>;

constructor(params: {
status: number;
code: ApiErrorCode;
message: string;
details?: Record<string, string>;
cause?: unknown;
}) {
super(params.message, params.cause ? { cause: params.cause } : undefined);
this.name = 'ApiError';
this.status = params.status;
this.code = params.code;
this.details = params.details;
}

static unauthorized(message = 'Unauthorized'): ApiError {
return new ApiError({ status: 401, code: 'UNAUTHORIZED', message });
}

static badRequest(message: string, details?: Record<string, string>, cause?: unknown): ApiError {
return new ApiError({ status: 400, code: 'BAD_REQUEST', message, details, cause });
}

static validation(details: Record<string, string>): ApiError {
return new ApiError({
status: 422,
code: 'VALIDATION_ERROR',
message: 'Validation failed',
details,
});
}

static notFound(message = 'Not found'): ApiError {
return new ApiError({ status: 404, code: 'NOT_FOUND', message });
}

static conflict(message: string, details?: Record<string, string>, cause?: unknown): ApiError {
return new ApiError({ status: 409, code: 'ROOM_NAME_CONFLICT', message, details, cause });
}

static constraint(message: string, details?: Record<string, string>, cause?: unknown): ApiError {
return new ApiError({ status: 422, code: 'DB_CONSTRAINT_VIOLATION', message, details, cause });
}
}



================================================
FILE: frontend/src/app/shared/confirm-dialog/confirm-dialog.component.ts
================================================
import { Component, Inject } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';
import { MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';

export type ConfirmDialogData = {
title: string;
message: string;
confirmText?: string;
cancelText?: string;
};

@Component({
selector: 'app-confirm-dialog',
standalone: true,
imports: [MatDialogModule, MatButtonModule],
template: `
    <h2 mat-dialog-title>{{ data.title }}</h2>
    <mat-dialog-content>
      <p>{{ data.message }}</p>
    </mat-dialog-content>
    <mat-dialog-actions align="end">
      <button mat-button mat-dialog-close>{{ data.cancelText ?? 'Anuluj' }}</button>
      <button mat-flat-button color="warn" [mat-dialog-close]="true">
        {{ data.confirmText ?? 'Potwierdz' }}
      </button>
    </mat-dialog-actions>
  `,
})
export class ConfirmDialogComponent {
constructor(@Inject(MAT_DIALOG_DATA) readonly data: ConfirmDialogData) {}
}



================================================
FILE: frontend/src/app/user/pages/user-edit-page/user-edit-page.component.html
================================================
<section class="user-edit-page">
  <header class="user-edit-page__header">
    <div>
      <h1>Edycja uzytkownika</h1>
      <p>Ten widok jest pusty w MVP.</p>
    </div>
  </header>

  <section class="user-edit-page__empty">
    <p>Wkrotce pojawi sie formularz edycji profilu.</p>
  </section>

  <section class="user-edit-page__actions">
    <button
      mat-flat-button
      color="primary"
      type="button"
      (click)="addTestData()"
      [disabled]="isSeeding"
    >
      Dodaj dane testowe
    </button>
    <div class="user-edit-page__loading" *ngIf="isSeeding">
      <mat-progress-spinner diameter="20"></mat-progress-spinner>
      <span>Tworzenie danych testowych...</span>
    </div>
  </section>
</section>



================================================
FILE: frontend/src/app/user/pages/user-edit-page/user-edit-page.component.scss
================================================
.user-edit-page {
display: grid;
gap: 20px;
max-width: 760px;
}

.user-edit-page__header {
display: grid;
gap: 6px;
}

.user-edit-page__header h1 {
margin: 0;
font-size: 28px;
}

.user-edit-page__header p {
margin: 0;
color: rgba(31, 31, 28, 0.7);
}

.user-edit-page__empty {
padding: 20px;
border-radius: 16px;
background: rgba(31, 31, 28, 0.05);
color: rgba(31, 31, 28, 0.75);
}

.user-edit-page__empty p {
margin: 0;
}

.user-edit-page__actions {
display: grid;
gap: 12px;
justify-items: start;
}

.user-edit-page__loading {
display: flex;
align-items: center;
gap: 10px;
color: rgba(31, 31, 28, 0.7);
}



================================================
FILE: frontend/src/app/user/pages/user-edit-page/user-edit-page.component.ts
================================================
import { NgIf } from '@angular/common';
import { HttpClient } from '@angular/common/http';
import { Component, inject } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar, MatSnackBarModule } from '@angular/material/snack-bar';
import { firstValueFrom } from 'rxjs';
import { FurnitureApi } from '../../../furniture/furniture.api';
import { ItemsApi } from '../../../items/items.api';
import { RoomsApi } from '../../../rooms/rooms.api';
import { ApiError } from '../../../shared/api-error';

@Component({
selector: 'app-user-edit-page',
standalone: true,
imports: [NgIf, MatButtonModule, MatProgressSpinnerModule, MatSnackBarModule],
templateUrl: './user-edit-page.component.html',
styleUrls: ['./user-edit-page.component.scss'],
})
export class UserEditPageComponent {
private readonly roomsApi = inject(RoomsApi);
private readonly furnitureApi = inject(FurnitureApi);
private readonly itemsApi = inject(ItemsApi);
private readonly snackBar = inject(MatSnackBar);
private readonly http = inject(HttpClient);

isSeeding = false;

async addTestData(): Promise<void> {
if (this.isSeeding) {
return;
}

    this.isSeeding = true;

    try {
      const seedData = await firstValueFrom(
        this.http.get<SeedData>('assets/seed-data.json')
      );

      for (const roomSeed of seedData.rooms) {
        const room = await this.roomsApi.createRoom({
          name: roomSeed.name,
          color: roomSeed.color,
        });

        const cells = createRoomCells(roomSeed.width, roomSeed.height);
        await this.roomsApi.replaceRoomCells(room.id, { cells });

        for (const furnitureSeed of roomSeed.furniture) {
          const furniture = await this.furnitureApi.createFurniture({
            room_id: room.id,
            name: furnitureSeed.name,
            description: furnitureSeed.description,
            color: furnitureSeed.color,
          });

          await this.furnitureApi.upsertFurniturePlacement(furniture.id, {
            room_id: room.id,
            x: furnitureSeed.placement.x,
            y: furnitureSeed.placement.y,
            width_cells: furnitureSeed.placement.width_cells,
            height_cells: furnitureSeed.placement.height_cells,
          });

          await this.itemsApi.createFurnitureItems(furniture.id, {
            items: furnitureSeed.items.map((item) => ({ name: item.name })),
          });
        }
      }

      this.snackBar.open('Dane testowe zostaly dodane.', 'Zamknij', { duration: 4000 });
    } catch (err: unknown) {
      const message = this.formatError(err);
      this.snackBar.open(message, 'Zamknij', { duration: 5000 });
    } finally {
      this.isSeeding = false;
    }
}

private formatError(error: unknown): string {
if (error instanceof ApiError) {
return error.message;
}

    if (error instanceof Error) {
      return error.message;
    }

    return 'Wystapil nieznany blad.';
}
}

function createRoomCells(width: number, height: number): { x: number; y: number }[] {
const cells: { x: number; y: number }[] = [];
for (let y = 0; y < height; y += 1) {
for (let x = 0; x < width; x += 1) {
cells.push({ x, y });
}
}
return cells;
}

type SeedData = {
rooms: SeedRoom[];
};

type SeedRoom = {
name: string;
color: string;
width: number;
height: number;
furniture: SeedFurniture[];
};

type SeedFurniture = {
name: string;
description: string;
color: string;
placement: {
x: number;
y: number;
width_cells: number;
height_cells: number;
};
items: SeedItem[];
};

type SeedItem = {
name: string;
};



================================================
FILE: frontend/src/assets/seed-data.json
================================================
{
"rooms": [
{
"name": "Duzy pokoj",
"color": "#b07b5a",
"width": 14,
"height": 12,
"furniture": [
{
"name": "Sofa",
"description": "Sofa trzyosobowa",
"color": "#ff1744",
"placement": { "x": 1, "y": 1, "width_cells": 2, "height_cells": 2 },
"items": [
{ "name": "Poduszka dekoracyjna" },
{ "name": "Koc" },
{ "name": "Pilot do TV" },
{ "name": "Magazyn" },
{ "name": "Ksiazka" },
{ "name": "Lampa stojaca" },
{ "name": "Latarka" },
{ "name": "Notes" },
{ "name": "Dlugopis" },
{ "name": "Sluchawki" }
]
},
{
"name": "Stolik kawowy",
"description": "Stolik kawowy z polka",
"color": "#ff6d00",
"placement": { "x": 4, "y": 2, "width_cells": 1, "height_cells": 1 },
"items": [
{ "name": "Miska" },
{ "name": "Swieczka" },
{ "name": "Podkladki" },
{ "name": "Pilot do soundbara" },
{ "name": "Etui na okulary" },
{ "name": "Kostki do gry" },
{ "name": "Album ze zdjeciami" },
{ "name": "Zapalniczka" },
{ "name": "Serwetki" },
{ "name": "Brelok" }
]
},
{
"name": "Szafka RTV",
"description": "Szafka pod telewizor",
"color": "#ffea00",
"placement": { "x": 8, "y": 1, "width_cells": 2, "height_cells": 1 },
"items": [
{ "name": "Dekoder" },
{ "name": "Konsola" },
{ "name": "Pad" },
{ "name": "Kable HDMI" },
{ "name": "Pilot zapasowy" },
{ "name": "Instrukcja" },
{ "name": "Gry" },
{ "name": "Plyty" },
{ "name": "Adapter" },
{ "name": "Baterie" }
]
},
{
"name": "Regal",
"description": "Regal na ksiazki",
"color": "#00c853",
"placement": { "x": 2, "y": 6, "width_cells": 1, "height_cells": 3 },
"items": [
{ "name": "Ksiazka kucharska" },
{ "name": "Powiesc" },
{ "name": "Poradnik" },
{ "name": "Segregator" },
{ "name": "Zeszyt" },
{ "name": "Album" },
{ "name": "Plyty CD" },
{ "name": "Gra planszowa" },
{ "name": "Pudelko" },
{ "name": "Ramka" }
]
},
{
"name": "Komoda",
"description": "Komoda z szufladami",
"color": "#00bfa5",
"placement": { "x": 10, "y": 6, "width_cells": 2, "height_cells": 1 },
"items": [
{ "name": "Obrus" },
{ "name": "Kable" },
{ "name": "Szkicownik" },
{ "name": "Zasilacz" },
{ "name": "Karty" },
{ "name": "Instrukcje" },
{ "name": "Ladowarka" },
{ "name": "Kosmetyczka" },
{ "name": "Spinacze" },
{ "name": "Baterie zapasowe" }
]
}
]
},
{
"name": "Sypialnia",
"color": "#8f6d7d",
"width": 12,
"height": 10,
"furniture": [
{
"name": "Lozko",
"description": "Lozko dwuosobowe",
"color": "#00b0ff",
"placement": { "x": 2, "y": 2, "width_cells": 2, "height_cells": 3 },
"items": [
{ "name": "Poduszka" },
{ "name": "Koldra" },
{ "name": "Przescieradlo" },
{ "name": "Poszewka" },
{ "name": "Koc" },
{ "name": "Poduszka zapasowa" },
{ "name": "Ksiazka na noc" },
{ "name": "Budzik" },
{ "name": "Maska do spania" },
{ "name": "Woda" }
]
},
{
"name": "Szafa",
"description": "Szafa na ubrania",
"color": "#2962ff",
"placement": { "x": 6, "y": 1, "width_cells": 2, "height_cells": 3 },
"items": [
{ "name": "Koszula" },
{ "name": "Spodnie" },
{ "name": "Sweter" },
{ "name": "Kurtka" },
{ "name": "Sukienka" },
{ "name": "Skpetki" },
{ "name": "Pasek" },
{ "name": "Torba" },
{ "name": "Czapka" },
{ "name": "Buty" }
]
},
{
"name": "Szafka nocna",
"description": "Szafka nocna",
"color": "#651fff",
"placement": { "x": 1, "y": 6, "width_cells": 1, "height_cells": 1 },
"items": [
{ "name": "Lampka" },
{ "name": "Okulary" },
{ "name": "Telefon" },
{ "name": "Ladowarka" },
{ "name": "Notatnik" },
{ "name": "Dlugopis" },
{ "name": "Krem" },
{ "name": "Balsam" },
{ "name": "Chusteczki" },
{ "name": "Balsam do ust" }
]
},
{
"name": "Komoda",
"description": "Komoda z szufladami",
"color": "#c51162",
"placement": { "x": 4, "y": 6, "width_cells": 2, "height_cells": 1 },
"items": [
{ "name": "Bielizna" },
{ "name": "Reczniki" },
{ "name": "Pizama" },
{ "name": "Posciel" },
{ "name": "Skapety sportowe" },
{ "name": "Apaszka" },
{ "name": "Zegarek" },
{ "name": "Lustereczko" },
{ "name": "Etui" },
{ "name": "Saszetka" }
]
},
{
"name": "Biurko",
"description": "Biurko do pracy",
"color": "#4e342e",
"placement": { "x": 8, "y": 6, "width_cells": 2, "height_cells": 1 },
"items": [
{ "name": "Laptop" },
{ "name": "Mysz" },
{ "name": "Klawiatura" },
{ "name": "Notes" },
{ "name": "Dlugopis" },
{ "name": "Lampka" },
{ "name": "Kabel USB" },
{ "name": "Zeszyt" },
{ "name": "Teczka" },
{ "name": "Sluchawki" }
]
}
]
},
{
"name": "Kuchnia",
"color": "#b28b5f",
"width": 13,
"height": 11,
"furniture": [
{
"name": "Blat",
"description": "Blat roboczy",
"color": "#ff1744",
"placement": { "x": 1, "y": 1, "width_cells": 2, "height_cells": 1 },
"items": [
{ "name": "Deska do krojenia" },
{ "name": "Noz" },
{ "name": "Miska" },
{ "name": "Cedzak" },
{ "name": "Waga" },
{ "name": "Tarka" },
{ "name": "Sitko" },
{ "name": "Miska mala" },
{ "name": "Scierka" },
{ "name": "Gabka" }
]
},
{
"name": "Szafka dolna",
"description": "Szafka z garnkami",
"color": "#ff6d00",
"placement": { "x": 4, "y": 1, "width_cells": 2, "height_cells": 2 },
"items": [
{ "name": "Garnek" },
{ "name": "Patelnia" },
{ "name": "Pokrywka" },
{ "name": "Rondel" },
{ "name": "Miski" },
{ "name": "Forma" },
{ "name": "Talerze" },
{ "name": "Miska duza" },
{ "name": "Pojemnik" },
{ "name": "Dzbanek" }
]
},
{
"name": "Szafka wiszaca",
"description": "Szafka na szklanki",
"color": "#ffea00",
"placement": { "x": 7, "y": 1, "width_cells": 2, "height_cells": 1 },
"items": [
{ "name": "Szklanki" },
{ "name": "Kubki" },
{ "name": "Filizanki" },
{ "name": "Spodki" },
{ "name": "Dzbanuszek" },
{ "name": "Cukiernica" },
{ "name": "Mlecznik" },
{ "name": "Termos" },
{ "name": "Kieliszki" },
{ "name": "Karafka" }
]
},
{
"name": "Lodowka",
"description": "Lodowka z zamrazarka",
"color": "#00c853",
"placement": { "x": 10, "y": 1, "width_cells": 2, "height_cells": 3 },
"items": [
{ "name": "Mleko" },
{ "name": "Jajka" },
{ "name": "Maslo" },
{ "name": "Ser" },
{ "name": "Szynka" },
{ "name": "Jogurt" },
{ "name": "Warzywa" },
{ "name": "Owoce" },
{ "name": "Woda" },
{ "name": "Sok" }
]
},
{
"name": "Stol",
"description": "Stol kuchenny",
"color": "#00bfa5",
"placement": { "x": 3, "y": 6, "width_cells": 2, "height_cells": 2 },
"items": [
{ "name": "Obrus" },
{ "name": "Serwetki" },
{ "name": "Solniczka" },
{ "name": "Pieprzniczka" },
{ "name": "Miseczka" },
{ "name": "Dzbanek" },
{ "name": "Podkladki" },
{ "name": "Kwiat" },
{ "name": "Swieczka" },
{ "name": "Cukier" }
]
}
]
},
{
"name": "Lazienka",
"color": "#6d8fa1",
"width": 10,
"height": 12,
"furniture": [
{
"name": "Szafka pod umywalke",
"description": "Szafka z kosmetykami",
"color": "#00b0ff",
"placement": { "x": 1, "y": 1, "width_cells": 2, "height_cells": 1 },
"items": [
{ "name": "Mydlo" },
{ "name": "Szampon" },
{ "name": "Odzywka" },
{ "name": "Pasta do zebow" },
{ "name": "Szczoteczka" },
{ "name": "Nici" },
{ "name": "Dezodorant" },
{ "name": "Krem" },
{ "name": "Gabka" },
{ "name": "Waciki" }
]
},
{
"name": "Polka",
"description": "Polka na reczniki",
"color": "#2962ff",
"placement": { "x": 4, "y": 1, "width_cells": 1, "height_cells": 2 },
"items": [
{ "name": "Recznik duzy" },
{ "name": "Recznik maly" },
{ "name": "Dywanik" },
{ "name": "Koszyk" },
{ "name": "Papier toaletowy" },
{ "name": "Plyn do szyb" },
{ "name": "Szczotka" },
{ "name": "Mop" },
{ "name": "Proszek" },
{ "name": "Gumowe rekawice" }
]
},
{
"name": "Szafka wysoka",
"description": "Szafka na zapasy",
"color": "#651fff",
"placement": { "x": 6, "y": 1, "width_cells": 2, "height_cells": 3 },
"items": [
{ "name": "Papier toaletowy" },
{ "name": "Zapasy mydla" },
{ "name": "Plastry" },
{ "name": "Woda utleniona" },
{ "name": "Maszynka" },
{ "name": "Pianka" },
{ "name": "Reczniki papierowe" },
{ "name": "Srodki czystosci" },
{ "name": "Szczotka" },
{ "name": "Kosz" }
]
},
{
"name": "Kosz na pranie",
"description": "Kosz na pranie",
"color": "#c51162",
"placement": { "x": 1, "y": 5, "width_cells": 1, "height_cells": 2 },
"items": [
{ "name": "Kosz na bielizne" },
{ "name": "Proszek" },
{ "name": "Plyn" },
{ "name": "Zawieszka" },
{ "name": "Klamerki" },
{ "name": "Worki" },
{ "name": "Odplamiacz" },
{ "name": "Recznik" },
{ "name": "Szczotka" },
{ "name": "Worki zapasowe" }
]
},
{
"name": "Polka prysznicowa",
"description": "Polka w prysznicu",
"color": "#4e342e",
"placement": { "x": 4, "y": 7, "width_cells": 1, "height_cells": 1 },
"items": [
{ "name": "Zel pod prysznic" },
{ "name": "Szampon" },
{ "name": "Odzywka" },
{ "name": "Mydlo" },
{ "name": "Gabeczka" },
{ "name": "Gabka" },
{ "name": "Maszynka" },
{ "name": "Peeling" },
{ "name": "Myjka" },
{ "name": "Olejek" }
]
}
]
}
]
}



================================================
FILE: frontend/src/assets/.gitkeep
================================================
[Empty file]


================================================
FILE: frontend/src/db/database.types.ts
================================================
export type Json =
| string
| number
| boolean
| null
| { [key: string]: Json | undefined }
| Json[]

export type Database = {
graphql_public: {
Tables: {
[_ in never]: never
}
Views: {
[_ in never]: never
}
Functions: {
graphql: {
Args: {
extensions?: Json
operationName?: string
query?: string
variables?: Json
}
Returns: Json
}
}
Enums: {
[_ in never]: never
}
CompositeTypes: {
[_ in never]: never
}
}
public: {
Tables: {
event_logs: {
Row: {
event_time: string
furniture_id: string | null
id: number
item_id: string | null
message: string
room_id: string | null
user_id: string
}
Insert: {
event_time?: string
furniture_id?: string | null
id?: number
item_id?: string | null
message: string
room_id?: string | null
user_id: string
}
Update: {
event_time?: string
furniture_id?: string | null
id?: number
item_id?: string | null
message?: string
room_id?: string | null
user_id?: string
}
Relationships: [
{
foreignKeyName: "event_logs_furniture_id_fkey"
columns: ["furniture_id"]
isOneToOne: false
referencedRelation: "furniture"
referencedColumns: ["id"]
},
{
foreignKeyName: "event_logs_item_id_fkey"
columns: ["item_id"]
isOneToOne: false
referencedRelation: "items"
referencedColumns: ["id"]
},
{
foreignKeyName: "event_logs_room_id_fkey"
columns: ["room_id"]
isOneToOne: false
referencedRelation: "rooms"
referencedColumns: ["id"]
},
]
}
furniture: {
Row: {
color: string
created_at: string
created_by: string
description: string | null
id: string
name: string
room_id: string
updated_at: string
user_id: string
}
Insert: {
color?: string
created_at?: string
created_by: string
description?: string | null
id?: string
name: string
room_id: string
updated_at?: string
user_id: string
}
Update: {
color?: string
created_at?: string
created_by?: string
description?: string | null
id?: string
name?: string
room_id?: string
updated_at?: string
user_id?: string
}
Relationships: [
{
foreignKeyName: "furniture_room_id_fkey"
columns: ["room_id"]
isOneToOne: false
referencedRelation: "rooms"
referencedColumns: ["id"]
},
]
}
furniture_placements: {
Row: {
furniture_id: string
height_cells: number
room_id: string
width_cells: number
x: number
y: number
}
Insert: {
furniture_id: string
height_cells: number
room_id: string
width_cells: number
x: number
y: number
}
Update: {
furniture_id?: string
height_cells?: number
room_id?: string
width_cells?: number
x?: number
y?: number
}
Relationships: [
{
foreignKeyName: "furniture_placements_furniture_id_fkey"
columns: ["furniture_id"]
isOneToOne: true
referencedRelation: "furniture"
referencedColumns: ["id"]
},
{
foreignKeyName: "furniture_placements_room_id_fkey"
columns: ["room_id"]
isOneToOne: false
referencedRelation: "rooms"
referencedColumns: ["id"]
},
]
}
items: {
Row: {
created_at: string
created_by: string
furniture_id: string
id: string
name: string
updated_at: string
user_id: string
}
Insert: {
created_at?: string
created_by: string
furniture_id: string
id?: string
name: string
updated_at?: string
user_id: string
}
Update: {
created_at?: string
created_by?: string
furniture_id?: string
id?: string
name?: string
updated_at?: string
user_id?: string
}
Relationships: [
{
foreignKeyName: "items_furniture_id_fkey"
columns: ["furniture_id"]
isOneToOne: false
referencedRelation: "furniture"
referencedColumns: ["id"]
},
]
}
onboarding: {
Row: {
completed_at: string | null
last_step: string | null
user_id: string
}
Insert: {
completed_at?: string | null
last_step?: string | null
user_id: string
}
Update: {
completed_at?: string | null
last_step?: string | null
user_id?: string
}
Relationships: []
}
room_cells: {
Row: {
room_id: string
x: number
y: number
}
Insert: {
room_id: string
x: number
y: number
}
Update: {
room_id?: string
x?: number
y?: number
}
Relationships: [
{
foreignKeyName: "room_cells_room_id_fkey"
columns: ["room_id"]
isOneToOne: false
referencedRelation: "rooms"
referencedColumns: ["id"]
},
]
}
rooms: {
Row: {
color: string
created_at: string
created_by: string
id: string
name: string
updated_at: string
user_id: string
}
Insert: {
color?: string
created_at?: string
created_by: string
id?: string
name: string
updated_at?: string
user_id: string
}
Update: {
color?: string
created_at?: string
created_by?: string
id?: string
name?: string
updated_at?: string
user_id?: string
}
Relationships: []
}
}
Views: {
[_ in never]: never
}
Functions: {
purge_event_logs_older_than_30_days: { Args: never; Returns: undefined }
}
Enums: {
[_ in never]: never
}
CompositeTypes: {
[_ in never]: never
}
}
}

type DatabaseWithoutInternals = Omit<Database, "__InternalSupabase">

type DefaultSchema = DatabaseWithoutInternals[Extract<keyof Database, "public">]

export type Tables<
DefaultSchemaTableNameOrOptions extends | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
| { schema: keyof DatabaseWithoutInternals },
TableName extends DefaultSchemaTableNameOrOptions extends {
schema: keyof DatabaseWithoutInternals
}
? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
: never = never,
> = DefaultSchemaTableNameOrOptions extends {
schema: keyof DatabaseWithoutInternals
}
? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
Row: infer R
}
? R
: never
: DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
DefaultSchema["Views"])
? (DefaultSchema["Tables"] &
DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
Row: infer R
}
? R
: never
: never

export type TablesInsert<
DefaultSchemaTableNameOrOptions extends | keyof DefaultSchema["Tables"]
| { schema: keyof DatabaseWithoutInternals },
TableName extends DefaultSchemaTableNameOrOptions extends {
schema: keyof DatabaseWithoutInternals
}
? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
: never = never,
> = DefaultSchemaTableNameOrOptions extends {
schema: keyof DatabaseWithoutInternals
}
? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
Insert: infer I
}
? I
: never
: DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
Insert: infer I
}
? I
: never
: never

export type TablesUpdate<
DefaultSchemaTableNameOrOptions extends | keyof DefaultSchema["Tables"]
| { schema: keyof DatabaseWithoutInternals },
TableName extends DefaultSchemaTableNameOrOptions extends {
schema: keyof DatabaseWithoutInternals
}
? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
: never = never,
> = DefaultSchemaTableNameOrOptions extends {
schema: keyof DatabaseWithoutInternals
}
? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
Update: infer U
}
? U
: never
: DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
Update: infer U
}
? U
: never
: never

export type Enums<
DefaultSchemaEnumNameOrOptions extends | keyof DefaultSchema["Enums"]
| { schema: keyof DatabaseWithoutInternals },
EnumName extends DefaultSchemaEnumNameOrOptions extends {
schema: keyof DatabaseWithoutInternals
}
? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
: never = never,
> = DefaultSchemaEnumNameOrOptions extends {
schema: keyof DatabaseWithoutInternals
}
? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
: DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
: never

export type CompositeTypes<
PublicCompositeTypeNameOrOptions extends | keyof DefaultSchema["CompositeTypes"]
| { schema: keyof DatabaseWithoutInternals },
CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
schema: keyof DatabaseWithoutInternals
}
? keyof DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
: never = never,
> = PublicCompositeTypeNameOrOptions extends {
schema: keyof DatabaseWithoutInternals
}
? DatabaseWithoutInternals[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
: PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
: never

export const Constants = {
graphql_public: {
Enums: {},
},
public: {
Enums: {},
},
} as const



================================================
FILE: frontend/src/db/supabase.client.ts
================================================
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { environment } from '../environments/environment';
import { Database } from './database.types';

export const supabase: SupabaseClient<Database> = createClient(
environment.supabaseUrl,
environment.supabaseAnonKey,
{
auth: {
// Prevent LockManager contention with other local apps using the same Supabase project.
storageKey: 'sb-where-it-is-auth-token',
},
}
);

export const DEFAULT_USER_ID = '896c0357-0f16-4761-9fe6-fbccaa188386';





================================================
FILE: frontend/src/db/supabase.service.ts
================================================
import { Injectable } from '@angular/core';
import { SupabaseClient } from '@supabase/supabase-js';
import { supabase } from './supabase.client';
import { Database } from './database.types';

@Injectable({
providedIn: 'root',
})
export class SupabaseService {
private readonly client: SupabaseClient<Database> = supabase;

getClient(): SupabaseClient<Database> {
return this.client;
}
}




================================================
FILE: frontend/src/environments/environment.prod.ts
================================================
export const environment = {
production: true,
supabaseUrl: 'https://YOUR_PROJECT_ID.supabase.co',
supabaseAnonKey: 'YOUR_PUBLIC_ANON_KEY',
};




================================================
FILE: frontend/src/environments/environment.ts
================================================
export const environment = {
production: false,
supabaseUrl: 'http://localhost:54321',
supabaseAnonKey: 'sb_publishable_ACJWlzQHlZjBrEguHvfOxg_3BJgxAaH',
};





</kod_projektu>

<struktura_projektu>


Directory structure:
└── src/
├── index.html
├── main.ts
├── styles.scss
├── types.ts
├── app/
│   ├── app.component.html
│   ├── app.component.scss
│   ├── app.component.spec.ts
│   ├── app.component.ts
│   ├── app.routes.ts
│   ├── auth/
│   │   ├── auth-session.module.ts
│   │   ├── auth-session.service.ts
│   │   ├── auth.api.ts
│   │   ├── auth.errors.ts
│   │   ├── auth.types.ts
│   │   ├── auth.validation.ts
│   │   ├── components/
│   │   │   ├── auth-form-card.component.html
│   │   │   ├── auth-form-card.component.scss
│   │   │   ├── auth-form-card.component.ts
│   │   │   ├── inline-error.component.ts
│   │   │   ├── password-field.component.html
│   │   │   ├── password-field.component.scss
│   │   │   └── password-field.component.ts
│   │   ├── guards/
│   │   │   ├── auth.guard.ts
│   │   │   └── guest.guard.ts
│   │   ├── layouts/
│   │   │   ├── auth-layout.component.html
│   │   │   ├── auth-layout.component.scss
│   │   │   └── auth-layout.component.ts
│   │   └── pages/
│   │       ├── forgot-password-page/
│   │       │   ├── forgot-password-page.component.html
│   │       │   ├── forgot-password-page.component.scss
│   │       │   └── forgot-password-page.component.ts
│   │       ├── login-page/
│   │       │   ├── login-page.component.html
│   │       │   ├── login-page.component.scss
│   │       │   └── login-page.component.ts
│   │       ├── register-page/
│   │       │   ├── register-page.component.html
│   │       │   ├── register-page.component.scss
│   │       │   └── register-page.component.ts
│   │       └── reset-password-page/
│   │           ├── reset-password-page.component.html
│   │           ├── reset-password-page.component.scss
│   │           └── reset-password-page.component.ts
│   ├── furniture/
│   │   ├── furniture.api.ts
│   │   ├── furniture.errors.ts
│   │   ├── furniture.types.ts
│   │   ├── furniture.validation.ts
│   │   ├── furniture.view-models.ts
│   │   └── components/
│   │       ├── furniture-card.component.ts
│   │       ├── furniture-form-dialog.component.ts
│   │       └── furniture-list.component.ts
│   ├── items/
│   │   ├── items.api.ts
│   │   ├── items.errors.ts
│   │   ├── items.types.ts
│   │   ├── items.validation.ts
│   │   ├── items.view-models.ts
│   │   └── components/
│   │       ├── furniture-items-dialog.component.ts
│   │       ├── item-row.component.ts
│   │       ├── items-bulk-add-form.component.ts
│   │       ├── items-dialog-actions.component.ts
│   │       └── items-list.component.ts
│   ├── rooms/
│   │   ├── room-details.facade.ts
│   │   ├── room-editor.facade.ts
│   │   ├── room-grid-editor.service.ts
│   │   ├── rooms-list.facade.ts
│   │   ├── rooms.api.ts
│   │   ├── rooms.errors.ts
│   │   ├── rooms.types.ts
│   │   ├── rooms.validation.ts
│   │   ├── rooms.view-models.ts
│   │   ├── components/
│   │   │   ├── room-card.component.ts
│   │   │   ├── room-color-picker.component.ts
│   │   │   ├── room-editor-actions.component.ts
│   │   │   ├── room-form.component.ts
│   │   │   ├── room-grid-editor.component.ts
│   │   │   ├── room-grid-preview.component.ts
│   │   │   ├── rooms-list-header.component.ts
│   │   │   └── rooms-list.component.ts
│   │   └── pages/
│   │       ├── room-details-page/
│   │       │   ├── room-details-page.component.html
│   │       │   ├── room-details-page.component.scss
│   │       │   └── room-details-page.component.ts
│   │       ├── room-editor-page/
│   │       │   ├── room-editor-page.component.html
│   │       │   ├── room-editor-page.component.scss
│   │       │   └── room-editor-page.component.ts
│   │       └── rooms-list-page/
│   │           ├── rooms-list-page.component.html
│   │           ├── rooms-list-page.component.scss
│   │           └── rooms-list-page.component.ts
│   ├── search/
│   │   ├── search.api.ts
│   │   ├── search.errors.ts
│   │   ├── search.types.ts
│   │   ├── search.validation.ts
│   │   ├── search.view-models.ts
│   │   ├── components/
│   │   │   ├── search-empty-state.component.ts
│   │   │   ├── search-form.component.ts
│   │   │   ├── search-result-item.component.ts
│   │   │   └── search-results-list.component.ts
│   │   └── pages/
│   │       └── search-page/
│   │           ├── search-page.component.html
│   │           ├── search-page.component.scss
│   │           └── search-page.component.ts
│   ├── shared/
│   │   ├── api-error.ts
│   │   └── confirm-dialog/
│   │       └── confirm-dialog.component.ts
│   └── user/
│       └── pages/
│           └── user-edit-page/
│               ├── user-edit-page.component.html
│               ├── user-edit-page.component.scss
│               └── user-edit-page.component.ts
├── assets/
│   ├── seed-data.json
│   └── .gitkeep
├── db/
│   ├── database.types.ts
│   ├── supabase.client.ts
│   └── supabase.service.ts
└── environments/
├── environment.prod.ts
└── environment.ts


</struktura_projektu>

Twoim zadaniem jest wygenerowanie szczegółowego planu testów, który będzie dostosowany do specyfiki projektu,
uwzględniając wykorzystywane technologie, strukturę kodu oraz kluczowe elementy repozytorium. Plan testów powinien być
napisany w języku polskim.

Przed stworzeniem planu testów, przeprowadź dogłębną analizę projektu wewnątrz bloku <analiza_projektu> w swoim bloku
myślowym. W analizie uwzględnij:

1. Kluczowe komponenty projektu wynikające z analizy kodu:
    - Wymień i opisz główne komponenty projektu
2. Specyfikę stosu technologicznego i jego wpływ na strategię testowania:
    - Przeanalizuj każdy element stosu technologicznego i jego implikacje dla testowania
3. Priorytety testowe bazujące na strukturze repozytorium:
    - Zidentyfikuj i uszereguj obszary testowe według ważności
4. Potencjalne obszary ryzyka wymagające szczególnej uwagi w testach:
    - Wymień potencjalne ryzyka i uzasadnij, dlaczego wymagają specjalnej uwagi

Po zakończeniu analizy, stwórz plan testów wewnątrz bloku <plan_testów>. Plan powinien zawierać:

1. Wprowadzenie i cele testowania
2. Zakres testów
3. Typy testów do przeprowadzenia (np. testy jednostkowe, integracyjne, wydajnościowe)
4. Scenariusze testowe dla kluczowych funkcjonalności
5. Środowisko testowe
6. Narzędzia do testowania
7. Harmonogram testów
8. Kryteria akceptacji testów
9. Role i odpowiedzialności w procesie testowania
10. Procedury raportowania błędów

Pamiętaj, aby plan testów był:

- Dokładnie dostosowany do kontekstu projektu
- Uwzględniał specyfikę wykorzystywanych technologii
- Priorytetyzował kluczowe elementy repozytorium
- Był napisany w języku polskim
- Prezentował wysoką jakość i profesjonalizm

Rozpocznij od analizy, a następnie przejdź do tworzenia planu testów. Twój końcowy wynik powinien składać się tylko z
planu testów i nie powinien powielać ani streszczać żadnej pracy wykonanej w bloku analizy projektu.

Przedstaw ten plan w formacie Markdown.